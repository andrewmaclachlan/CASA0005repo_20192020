[
["index.html", "CASA0005 Geographic Information Systems and Science Welcome The world of GIS Getting started Offline viewing More help Noticed a mistake?", " CASA0005 Geographic Information Systems and Science Andy MacLachlan and Adam Dennett 2019-07-11 Welcome Welcome to the CASA0005 Geographic Information Systems and Science online pratical handbook. This website is hosted on GitHub and holds all the practical instructions and data. All data used within the practicals is available online, however occasionally websites can undergo maintenance or be inaccessible due to political factors such as government shutdowns. If you need the practical data you can access it from my github repository here: https://github.com/andrewmaclachlan/CASA0005book Practical data is divided into the relevant sessions, although sometimes i’ll refer to a dataset used within a previous week. The world of GIS Spatial analysis can yield fascinating insights into geographical relationships. However, at times it can be difficult to work with. You will get lots of error messages and have software crash. The academic staff are here to help you work through these practicals but we do not know everything. It’s a good idea to become familar with online sources of help, such as: Stack Exchange https://stackexchange.com/ QGIS documemtation https://docs.qgis.org/3.4/en/docs/index.html R documentation https://www.rdocumentation.org/ ArcGIS help pages https://support.esri.com/en Getting started One of the issues with GIS is that many of the files we will be working with are quite large. Fortunately in recent years UCL has seriously beefed up the storage available for students. You now get 100GB of free storage, which should be plenty for the work you will be doing this year! The Bartlett faculty has several gigabytes of storage space available on their central servers, so before we get started, we will connect to our N drive to carry out all of our practical work over the coming weeks. Offline viewing The best way to view this practical book is through the website. However if you are unable to access the internet you can either download the .epub book or save specific webpages for offline viewing. Insturctions for Google Chrome are provided here: https://support.google.com/chrome/answer/7343019?co=GENIE.Platform%3DDesktop&amp;hl=en&amp;oco=1 More help If you need specific assistance with this course please: Check the module handbook for queries relating to assignments / deadlines Speak to a member of the teaching team in the computer lab sessions Ask a question at the end of a lecture (time permitting) Ask a question on slack Due to the size of the class we will only reply to messages on slack so all students can see the discussion. If after persuing all these avenues you still need help you can book into our office hours are specified below. These meetings are to discuss a geographical concept in relation to the material/assignments or for any personal matters relevant to the completion of the course. These meetings are not to be used for specific technical issues. Problems of this nature should be addressed in the practical sessions. Andy: https://amaclachlan.youcanbook.me/ Adam: https://amaclachlan.youcanbook.me/ Noticed a mistake? No one is perfect, if you notice a mistake let us know through the GitHub issues tab…Don’t worry if you are unsure about what GitHub is we, cover it in the course. "],
["introduction-to-r.html", "Chapter 1 Introduction to R 1.1 Learning outcomes 1.2 Introduction 1.3 Reading data into R 1.4 Making maps using ggplot2", " Chapter 1 Introduction to R 1.1 Learning outcomes By the end of this practical you should be able to: Execute basic processing in R Examine, clean and manipulate comma seperate value (.csv) data Examine, clean and manipulate and plot spatial (.csv) data Produce interactive maps Evaluate the benefits of different data manipulation and mapping techniques 1.2 Introduction This practical is LONG but it will take you from not knowing much about R to making freaking cool interactive maps in one practical. As you can imagine, this will be a steep learning curve. I will give you all the code you need, it’s your job to read through the text very carefully and try to understand what bits of code are doing as you go. There will be bits of code you don’t fully understand. Don’t worry, the key is to revisit later and try to work out what is going on then. Learning R is a long and iterative process and this is just the start… If you want to learn more about R and indeed download the latest version for your own use, then visit the R project pages: http://www.r-project.org/ The Wikipedia page for those who want to know a little of the history of R can be found here: http://en.wikipedia.org/wiki/R_(programming_language) There is an almost endless supply of good R tutorials on the web. If you get stuck or want to learn even more R (and why would you not want to?!), I’d recommend trying some of the following R Tutorial websites: http://www.statmethods.net/index.html http://www.r-tutor.com/ http://www.cyclismo.org/tutorial/R/index.html http://www.cookbook-r.com/ If you want to really be up to date with the state of the art in R, then https://bookdown.org/ is a fantastic resource. It features free books by some of the pre-eminent names in the R scene - I would urge you to go and take a look. 1.2.1 Online forums are your friend!! With almost every problem you encounter with R, someone else will have had the same problem before you and posted it on a forum – someone will then post a solution below. My usual route is to Google the problem and I’ll then be directed to a post, usually on Stack Overflow, Stack Exchange or Cross Validated. When doing so try to think about the minimal working (or not working) example (MWE), by this i mean remove anything very specific to your problem. I’ve rarely not found a solution to a problem this way. Health warning Beware of posting questions on these forums yourself – contributors to these forums (especially the R ones!), whilst almost always extremely knowledgeable about R, have a bit of a reputation for being insert familiar pejorative term for less-than-polite-human-being here! As you might expect, people who have enough time to become total experts in R, have little time to work on their social skills!! Fortunately though, some other poor chump has usually taken that hit for you and you can still find a useful answer to your problem. If you are specifically more interested in the spatial side of R, then Alex Singleton and Chris Brunsdon at the Universities of Liverpool and Maynooth also have a number of very useful R Spatial Tutorials – http://rpubs.com/alexsingleton/ &amp; http://rpubs.com/chrisbrunsdon/ Robin Lovelace in Leeds is also frequently at the bleeding edge of developments in R spatial stuff, so keep an eye on his website too: http://robinlovelace.net/. Robin is also in the process of completing a book on GeoComputation in R, which you should definitely read! - https://geocompr.robinlovelace.net/ These websites are also very very good: https://pakillo.github.io/R-GIS-tutorial/ and http://www.maths.lancs.ac.uk/~rowlings/Teaching/UseR2012/cheatsheet.html 1.2.2 R and RStudio When you download and install R, you get the R Graphical User Interface (GUI) as standard (below). This is fine and some purists prefer using the clean, unfussy command-line original, but it has some limitations such as no graphical way to view data tables or keep track of what is in your working directory (there are a number of others too). Fortunately there are a number of software environments that have been developed for R to make it a little more user-friendly; the best of these by a long way is RStudio. RStudio can be downloaded for free from https://www.rstudio.com/. We covered the RStudio layout last week. 1.2.3 Getting started If you are some kind of masochist, you are welcome to use the bundled R GUI for all of your work. If pain is not your thing, then for this practical (and future practicals) I will assume that you are using RStudio. From the start menu on your computer, find and run R Studio Once RStudio has opened, the first thing we will do is create a new project – projects enable you to organise your work effectively and store all of the files you create and work with for a particular task. 2. To create a new project (and this will vary a little depending on the version of RStudio you are using), either select File &gt; New Project… or Project &gt; Create Project Select Start a project in a brand new working directory and create a new project in a directory of a new ‘wk2’ directory on your N: drive: My file directory (the second box here) will be different to yours as this is my teaching resources folder. Keep yours simple N:/GIS/wk2. RStudio should now open with three windows – the main R console on the left, with windows for your environment and files on the right. 1.2.4 Basics R has a very steep learning curve, but hopefully it won’t take long to get your head around the basics. For example, at its most simple R can be used as a calculator. In the console window (bottom left), just type the following and press enter: 1+5 ## [1] 6 or 4*5^2 ## [1] 100 As you can see R performs these calculations instantly and prints the results in the console. This is useful for quick calculations but less useful for writing scripts requiring multiple operations or saving these for future use. To save your scripts, you should create a new R Script file. Do this now: Select File &gt; New File &gt; R Script. The R Script should open up on the top-left of your GUI. From now on type everything in this R script file and save it 1.2.5 Scripts and some basic commands Usually one of the first things to do when starting a new R Script is to check that you are in the correct working directory. This is important especially if you are working on multiple projects in different locations. To do this type the following into your new empty R Script: getwd() ## [1] &quot;N:/Documents/Teaching/CASA0005practicals/CASA0005repo&quot; To run this line, hold Ctrl (Cmd on a Mac) and press the Return(↲) key (if you are in the standard R installation, you would run your script with Ctrl R). You should now see your current working directory appear in the console. Because of the new project we have already set up, this working directory should be correct, but if for any reason we wanted to change the working directory, we would use the setwd() function. For example, we wanted to change our directory to the documents folder on the C drive, we could run (don’t do this now): setwd(&quot;C:/Documents&quot;) When we are sure we are working in the correct working directory, we can save our script by clicking on the save icon on the script tab. Save your script as something like “wk2_part1” and you will see it appear in your files window on the right hand side. As you build up a document of R code, you should get into the habit of saving your script periodically in case of an unexpected software crash. We can now begin to write a script without the need to run each line every time we press enter. In the script editor type: A &lt;- 1 B &lt;- 2 C &lt;- A+B C ## [1] 3 Select (highlight) the three lines and run all three lines with Ctrl Return(↲). You will notice the lines appear in the console (the other window). If you type C and press enter in the console (C and then ctrl return in the script window) you should have the number 3 appear. From now on I recommend you type all the commands below in the script first and then run them. Copying and pasting from this document won’t necessarily work. You will also notice that in RStudio, values A, B and C will appear in your workspace window (top right). These variables are stored in memory for future use. Try giving A and B different values and see what happens. What about if you use lower case letters? You have just demonstrated one of the powerful aspects of R, which is that it is an object oriented programming language. A, B and C are all objects that have been assigned a value with the &lt;- symbol (you can also use the = sign, but it operates slightly differently to &lt;- in R, plus the arrow assignment has become standard over the years. Use alt - to type it automatically). This principle underlies the whole language and enables users to create ever more complex objects as they progress through their analysis. If you type: ls() ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; R will produce a list of objects that are currently active. rm(A) will remove the object A from the workspace (do ls() again to check this or look in your workspace window). 1.2.6 Functions Both rm() and ls() are known as functions. Functions are the other fundamental aspect to the R language. Functions can be thought of as single or multiple calculations that you apply to objects. They generally take the form of: function(object, parameter1, parameter2, parameter3...) You can write your own functions to carry out tasks (and we’ll come onto that in subsequent practical sessions), but normally you will just used one of the virtually infinite number of functions that other people have already written for us. 1.2.7 Basic plotting For example, one common function is the plot() function for displaying data as a graphical output. Add these lines to your script and run them as before and you can see some plot() outputs: #create some datasets, first a vector of 1-100 and 101-200 Data1 &lt;- c(1:100) Data2 &lt;- c(101:200) #Plot the data plot(Data1, Data2, col=&quot;red&quot;) #just for fun, create some more, this time some normally distributed #vectors of 100 numbers Data3 &lt;- rnorm(100, mean = 53, sd=34) Data4 &lt;- rnorm(100, mean = 64, sd=14) #plot plot(Data3, Data4, col=&quot;blue&quot;) In the code above, you will have noticed the # symbol. This signifies that whatever comes after it on that line is a comment. Comments are ignored by the R console and they allow you to annotate your code so that you know what it is doing. It is good programming practice to comment your code extensively so that you can keep track of what your scripts are for. 1.2.8 Help The previous lines of code also demonstrated a number of functions: c() concatenates a string of numbers together into a vector. 1:100 means produce the integers between and including 1:100, the plot() function plots the two data objects and includes a parameter to change the colour of the points. To understand what a function does, you can consult the R Help system. Simply type a question mark and then the function name; for example: ?plot In RStudio you will see the help file appear in the Help window in the bottom right of the GUI. Here you can also search for the help files for other functions in the search bar. 1.2.9 Data types Objects in R can exist as a number of different data types. These include a matrix, a vector, a data frame and a list. For the purposes of this practical we will focus on data frames. These are the most flexible data format in R (although tibbles are now becoming popular as well). Data frames can be conceptualised in a similar way to a spreadsheet with data held in rows and columns. They are the most commonly used object type in R and the most straightforward to create from the two vector objects we just created. df &lt;- data.frame(Data1, Data2) plot(df, col=&quot;green&quot;) If you have a very large data frame (thousands or millions of rows) it is useful to see only a selection of these. There are several ways of doing this: #show the first 10 and then last 10 rows of data in df... head(df) ## Data1 Data2 ## 1 1 101 ## 2 2 102 ## 3 3 103 ## 4 4 104 ## 5 5 105 ## 6 6 106 tail(df) ## Data1 Data2 ## 95 95 195 ## 96 96 196 ## 97 97 197 ## 98 98 198 ## 99 99 199 ## 100 100 200 You can also view elements of your data frame in RStudio by simply clicking on it in the top-right Environment window: 1.2.10 Elements of a data frame When programming you will frequently want to refer to different elements in a data frame or a vector/list. To select elements of a data frame, or subset it, you can refer specifically to ranges or elements of rows and columns. These are accessed using the single square bracket operator [], with the form: data.frame[row,column] Rows are always referenced first, before the comma, columns second, after the comma. Try the subsetting your df data frame with the following commands to see what is returned: df[1:10, 1] ## [1] 1 2 3 4 5 6 7 8 9 10 df[5:15,] ## Data1 Data2 ## 5 5 105 ## 6 6 106 ## 7 7 107 ## 8 8 108 ## 9 9 109 ## 10 10 110 ## 11 11 111 ## 12 12 112 ## 13 13 113 ## 14 14 114 ## 15 15 115 df[c(2,3,6),2] ## [1] 102 103 106 df[,1] ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ## [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 ## [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ## [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 You will note that the column headings are the names of the original objects creating the data frame. We can change these using the colnames() function: colnames(df)&lt;- c(&quot;column1&quot;, &quot;column2&quot;) To select or refer to these columns directly by name, we can either use the $ operator, which takes the form data.frame$columnName, e.g. df$column1 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ## [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 ## [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ## [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 or we can use the double square bracket operator [[]], and refer to our column by name using quotes e.g. df[[&quot;column1&quot;]] ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## [18] 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ## [52] 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 ## [69] 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 ## [86] 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 This again is useful if you have a lot of columns and you wish to efficiently extract one of them. 1.3 Reading data into R One of the most tedious things a spatial analyst / data scientist has to do is clean their data so it doesn’t cause problems for the software later. In the past, we would have needed to do this by hand - these days, we can use software to do much of this for us. I will now give you two options to arrive at a nice cleaned dataset. If you have issues with software packages etc, you might still need to via the old skool route, however, the new skool route will be much more satisfying if it works! For this example we are going to use the London Datastore Catalogue. Go to: https://data.london.gov.uk/dataset/london-datastore-catalogue and download the excel document. 1.3.1 Old skool cleaning Open the LondonData.xls file in Excel, and save as LondonData.csv into your wk2/RProject folder. Open your new .csv file in Excel. There might be some non-numeric values inside numeric columns which will cause problems in your analysis. These need to be removed before proceeding any further. To remove these, you can use the replace function in Excel. In the home tab under ‘Editing’ open up the find and replace dialogue box and enter the following into the find box: #VALUE! #n/a Leave the replace box empty each time and click Replace All to remove these from your file, before saving the file again. Once you have cleaned out all of the trixy characters from the file, to read it into R, we will use the read.csv() function: LondonDataOSK&lt;- read.csv(&quot;prac2_data/london_catalogue.csv&quot;) Note, I’ve made an R project for all these practicals, which is why my file path starts with prac2_data/. If you save the .csv in the same folder as the .Rproj then you can just use: LondonDataOSK&lt;- read.csv(&quot;LondonData.csv&quot;) If you look at the read.csv() help file - ?read.csv - you will see that we can actually include many more parameters when reading in a .csv file. For example, we could read in the same file as follows: # by default in R, the file path should be defined with / but on a #windows file system it is defined with \\. Using \\\\ instead allows R #to read the path correctly – alternatively, just use / LondonDataOSK&lt;- read.csv(&quot;prac2_data/london_catalogue.csv&quot;, header = TRUE, sep = &quot;,&quot;) This would specify the exact path; that the first row of the file contains header information; and the values in the file are separated with commas (not ; or : as can be the case sometimes). 1.3.2 New skool cleaning To clean our data as we read it in, we are going to use a package (more about packages later - for now, just think about it as a lovely gift from the R gods) called readr which comes bundled as part of the tidyverse package. If you want to find out more about the Tidyverse (and you really should) then you should start here: https://www.tidyverse.org/ - the Tidyverse package contains almost everything you need to become a kick-ass data scientist. ‘Tidy’ as a concept in data science is well worth reading about and you should start here with Hadley Wickham’s paper - http://vita.had.co.nz/papers/tidy-data.pdf Anyway, first install the package: install.packages(&quot;tidyverse&quot;, repos = &quot;https://www.stats.bris.ac.uk/R/&quot;) Now we can use the readr package which comes bundled as part of the tidyverse to read in some data (directly from the web this time - read.csv can do this too) and clean text characters out from the numeric columns before they cause problems: library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 3.6.1 #wang the data in straight from the web using read_csv, skipping over the &#39;n/a&#39; entries as you go... LondonData &lt;- read_csv(&quot;https://files.datapress.com/london/dataset/ward-profiles-and-atlas/2015-09-24T14:21:24/ward-profiles-excel-version.csv&quot;, na = &quot;n/a&quot;) note the use of read_csv here as opposed to read.csv. They are very similar, but read_csv is just a bit better - read this to understand why… Also, for those python fans out there - IT’S NOT THE SAME FUNCTION AS READ_CSV IN PYTHON 1.3.3 Examining your new data Your new data has been read in as a data frame / tibble (a tibble is just a data frame with a few extra bells and whistles). If you ever need to check what data type your new data set is, we can use the class() function: class(LondonData) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; # or, if you have your old skool data from step 24 above class(LondonDataOSK) We can also use the class function within another two functions (cbind() and lapply()) to check that our data has been read in correctly and that, for example, numeric data haven’t been read in as text or other variables. Run the following line of code: datatypelist &lt;- data.frame(cbind(lapply(LondonData,class))) You should see that all columns that should be numbers are read in as numeric. Try reading in LondonData again, but this time without excluding the ‘n/a’ values in the file, e.g. LondonData &lt;- read_csv(&quot;https://files.datapress.com/london/dataset/ward-profiles-and-atlas/2015-09-24T14:21:24/ward-profiles-excel-version.csv&quot;) Now run the datatypelist function again - you should see that some of the columns (those the n/a values in) have been read in as something other than numeric. This is why we need to exclude them. Isn’t readr great for helping us avoid reading in our numeric data as text! LondonData &lt;- edit(LondonData) It is also possible to quickly and easily summarise the data or look at the column headers using summary(df) ## column1 column2 ## Min. : 1.00 Min. :101.0 ## 1st Qu.: 25.75 1st Qu.:125.8 ## Median : 50.50 Median :150.5 ## Mean : 50.50 Mean :150.5 ## 3rd Qu.: 75.25 3rd Qu.:175.2 ## Max. :100.00 Max. :200.0 names(LondonData) ## [1] &quot;Ward name&quot; ## [2] &quot;Old code&quot; ## [3] &quot;New code&quot; ## [4] &quot;Population - 2015&quot; ## [5] &quot;Children aged 0-15 - 2015&quot; ## [6] &quot;Working-age (16-64) - 2015&quot; ## [7] &quot;Older people aged 65+ - 2015&quot; ## [8] &quot;% All Children aged 0-15 - 2015&quot; ## [9] &quot;% All Working-age (16-64) - 2015&quot; ## [10] &quot;% All Older people aged 65+ - 2015&quot; ## [11] &quot;Mean Age - 2013&quot; ## [12] &quot;Median Age - 2013&quot; ## [13] &quot;Area - Square Kilometres&quot; ## [14] &quot;Population density (persons per sq km) - 2013&quot; ## [15] &quot;% BAME - 2011&quot; ## [16] &quot;% Not Born in UK - 2011&quot; ## [17] &quot;% English is First Language of no one in household - 2011&quot; ## [18] &quot;General Fertility Rate - 2013&quot; ## [19] &quot;Male life expectancy -2009-13&quot; ## [20] &quot;Female life expectancy -2009-13&quot; ## [21] &quot;% children in reception year who are obese - 2011/12 to 2013/14&quot; ## [22] &quot;% children in year 6 who are obese- 2011/12 to 2013/14&quot; ## [23] &quot;Rate of All Ambulance Incidents per 1,000 population - 2014&quot; ## [24] &quot;Rates of ambulance call outs for alcohol related illness - 2014&quot; ## [25] &quot;Number Killed or Seriously Injured on the roads - 2014&quot; ## [26] &quot;In employment (16-64) - 2011&quot; ## [27] &quot;Employment rate (16-64) - 2011&quot; ## [28] &quot;Number of jobs in area - 2013&quot; ## [29] &quot;Employment per head of resident WA population - 2013&quot; ## [30] &quot;Rate of new registrations of migrant workers - 2011/12&quot; ## [31] &quot;Median House Price (&lt;U+00A3&gt;) - 2014&quot; ## [32] &quot;Number of properties sold - 2014&quot; ## [33] &quot;Median Household income estimate (2012/13)&quot; ## [34] &quot;Number of Household spaces - 2011&quot; ## [35] &quot;% detached houses - 2011&quot; ## [36] &quot;% semi-detached houses - 2011&quot; ## [37] &quot;% terraced houses - 2011&quot; ## [38] &quot;% Flat, maisonette or apartment - 2011&quot; ## [39] &quot;% Households Owned - 2011&quot; ## [40] &quot;% Households Social Rented - 2011&quot; ## [41] &quot;% Households Private Rented - 2011&quot; ## [42] &quot;% dwellings in council tax bands A or B - 2015&quot; ## [43] &quot;% dwellings in council tax bands C, D or E - 2015&quot; ## [44] &quot;% dwellings in council tax bands F, G or H - 2015&quot; ## [45] &quot;Claimant rate of key out-of-work benefits (working age client group) (2014)&quot; ## [46] &quot;Claimant Rate of Housing Benefit (2015)&quot; ## [47] &quot;Claimant Rate of Employment Support Allowance - 2014&quot; ## [48] &quot;Rate of JobSeekers Allowance (JSA) Claimants - 2015&quot; ## [49] &quot;% dependent children (0-18) in out-of-work households - 2014&quot; ## [50] &quot;% of households with no adults in employment with dependent children - 2011&quot; ## [51] &quot;% of lone parents not in employment - 2011&quot; ## [52] &quot;(ID2010) - Rank of average score (within London) - 2010&quot; ## [53] &quot;(ID2010) % of LSOAs in worst 50% nationally - 2010&quot; ## [54] &quot;Average GCSE capped point scores - 2014&quot; ## [55] &quot;Unauthorised Absence in All Schools (%) - 2013&quot; ## [56] &quot;% with no qualifications - 2011&quot; ## [57] &quot;% with Level 4 qualifications and above - 2011&quot; ## [58] &quot;A-Level Average Point Score Per Student - 2013/14&quot; ## [59] &quot;A-Level Average Point Score Per Entry; 2013/14&quot; ## [60] &quot;Crime rate - 2014/15&quot; ## [61] &quot;Violence against the person rate - 2014/15&quot; ## [62] &quot;Deliberate Fires per 1,000 population - 2014&quot; ## [63] &quot;% area that is open space - 2014&quot; ## [64] &quot;Cars per household - 2011&quot; ## [65] &quot;Average Public Transport Accessibility score - 2014&quot; ## [66] &quot;% travel by bicycle to work - 2011&quot; ## [67] &quot;Turnout at Mayoral election - 2012&quot; 1.3.4 Data manipulation in R Now we have some data read into R, we need to select a small subset to work on. The first thing we will do is select just the London Boroughs to work with. If you recall, the Borough data is at the bottom of the file. 1.3.4.1 Selecting rows Your borough data will probably be found between rows 626 and 658. Therefore we will first create a subset by selecting these rows into a new data frame and then reducing that data frame to just four columns. There are a few ways of doing this: We could select just the rows we need by explicitly specifying the range of rows we need: LondonBoroughs&lt;-LondonData[626:658,] There is also a subset() function in R. You could look that up and see whether you could create a subset with that. Or, we could try a cool ‘data sciency’ way of pulling out the rows we want with the knowledge that the codes for London Boroughs start with E09 (the wards in the rest of the file start with E05). Knowing this, we can use the grep() function which can use regular expressions to match patterns in text. Let’s try it! LondonData &lt;- data.frame(LondonData) LondonBoroughs &lt;- LondonData[grep(&quot;^E09&quot;,LondonData[,3]),] Check it worked: head(LondonBoroughs) AWWMAHGAWD!!! Pretty cool hey? What that function is saying is “grep (get) me all of the rows from the London Data data frame where the text in column 3 starts with (^) E09” You will notice that you will have two rows at the top for the City of London. This is because it features twice in the data set. That’s fine, we can just drop this row from our dataset: LondonBoroughs &lt;- LondonBoroughs[2:34,] 1.3.4.2 Selecting columns LondonBoroughs&lt;-LondonBoroughs[,c(1,19,20,21)] You will have noticed the use of square brackets above – these are very useful in R. Refer back to points 19-21 above if you can’t remember how they work. The c() function is also used here – this is the ‘combine’ function - another very useful function in R which allows arguments (in this case, column reference numbers) into a single value 1.3.4.3 Renaming columns You will notice that the column names are slightly misleading as we are now working with boroughs rather than wards. We can rename the columns to something more appropriate using the names() function (there are various other functions for renaming columns - for example colnames() if you want to rename multiple columns: #rename the column 1 in LondonBoroughs names(LondonBoroughs)[1] &lt;- c(&quot;Borough Name&quot;) 1.3.5 Plotting plot(LondonBoroughs$Male.life.expectancy..2009.13, LondonBoroughs$X..children.in.reception.year.who.are.obese...2011.12.to.2013.14) 1.3.6 Pimp my graph! Now, of course, because this is R, we can pimp this graph using something a bit more fancy than the base graphics functions: install.packages(&quot;plotly&quot;, repos = &quot;https://www.stats.bris.ac.uk/R/&quot;) library(plotly) ## Warning: package &#39;plotly&#39; was built under R version 3.6.1 plot_ly(LondonBoroughs, x = ~Male.life.expectancy..2009.13, y = ~X..children.in.reception.year.who.are.obese...2011.12.to.2013.14, text = ~LondonBoroughs$`Borough Name`, type = &quot;scatter&quot;, mode = &quot;markers&quot;) 1.3.7 Spatial Data in R This next part of the practical applies the same principles introduced above to the much more complex problem of handling spatial data within R. In this workshop we will produce a gallery of maps using many of the plotting tools available in R. The resulting maps will not be that meaningful- the focus here is on sound visualisation with R and not sound analysis (I know one is useless without the other!). Good quality spatial analysis will come in the rest of the module. Whilst the instructions are step by step you are encouraged to start deviating from them (trying different colours for example) to get a better understanding of what we are doing. 1.3.7.1 Packages In this section we’ll require even more specialist packages, so I should probably spend some more time explaining what packages actually are! Packages are bits of code that extend R beyond the basic statistical functionality it was originally designed for. For spatial data, they enable R to process spatial data formats, carry out analysis tasks and create some of the maps that follow. Bascially, without packages, R would be very limited. With packages, you can do virtually anything! One of the issues you will come across is that packages are being continually developed and updated and unless you keep your version of R updated and your packages updated, there may be some functions and options not available to you. This can be a problem, particularly with University installations which (at best) may only get updated once a year. Therefore, apologies in advance if things don’t work as intended! In R Studio all packages can be installed and activated in the ‘Packages’ tab in the bottom-right hand window: As with everything else in R though, we can also run everything from the command line. The first package we need to install for this part of the practical is maptools – either find and install it using the RStudio GUI or do the following: install.packages(&quot;maptools&quot;) There are a few other packages we’ll need to get to grips with. Some, like ggplot2 (one of the most influential R packages ever) are part of the tidyverse package we came across earlier. Others we will need to install for the first time. install.packages(c(&quot;OpenStreetMap&quot;, &quot;classInt&quot;, &quot;tmap&quot;)) install.packages(c(&quot;RColorBrewer&quot;, &quot;sp&quot;, &quot;rgeos&quot;, &quot;tmaptools&quot;, &quot;sf&quot;, &quot;downloader&quot;, &quot;rgdal&quot;, &quot;geojsonio&quot;))# might also need these ones Now that the packages have been installed you will not have to repeat the above steps again (when you use your account in these cluster rooms). Open a new script and save it to your working directory as “wk3_maps.r”. As before, type each of the lines of code into this window and then select and use the ctrl return keys to run them. Be sure to save your script often. The first task is to load the packages we have just installed. note, you might have some issues with the OpenStreetMap package if your installation of java on your computer doesn’t match your installation of R – e.g. if you have installed the 64bit version of R, you also need the 64bit version of java (same with the 32bit versions) - you may also need to install the package Rcpp separately and try again. Install Java 64-bit from: https://java.com/en/download/manual.jsp #Load Packages (ignore any error messages about being built under a #different R version): library(maptools) library(RColorBrewer) library(classInt) library(OpenStreetMap) library(sp) library(rgeos) library(tmap) library(tmaptools) library(sf) library(rgdal) library(geojsonio) 1.3.7.2 Background to spatial data in R R has a very well developed ecosystem of packages for working with Spatial Data. Early pioneers like Roger Bivand and Edzer Pebesma along with various colleagues were instrumental in writing packages to interface with some powerful open source libraries for working with spatial data, such as GDAL and GEOS. These were accessed via the rgdal and rgeos packages. The maptools package by Roger Bivand, amongst other things, allowed Shapefiles to be read into R. The sp package (along with spdep) by Edzer Pebesma was very important for defining a series of classes and methods for spatial data natively in R which then allowed others to write software to work with these formats. Other packages like raster advanced the analysis of gridded spatial data, while packages like classint and RColorbrewer facilitated the binning of data and colouring of choropleth maps. Whilst these packages were extremely important for advancing spatial data analysis in R, they were not always the most straightforward to use - making a map in R could take quite a lot of effort and they were static and visually basic. However, more recently new packages have arrived to change this. Now leaflet enables R to interface with the leaflet javascript library for online, dynamic maps. ggplot2 which was developed by Hadley Wickam and colleagues radically changed the way that people thought about and created graphical objects in R, including maps, and introduced a graphical style which has been the envy of other software to the extent that there are now libraries in Python which copy the ggplot2 style! Building on all of these, the new tmap (Thematic Map) package has changed the game completely and now enables us to read, write and manipulate spatial data and produce visually impressive and interactive maps, very easily. In parallel, the sf (Simple Features) package is helping us re-think the way that spatial data can be stored and manipulated. It’s exciting times for geographic information / spatial data science! 1.3.7.3 Making some choropleth maps Choropleth maps are thematic maps which colour areas according to some phenomenon. In our case, we are going to fill some irregular polygons (the London Boroughs) with a colour that corresponds to a particular attribute. As with all plots in R, there are multiple ways we can do this. The basic plot() function requires no data preparation but additional effort in colour selection/ adding the map key etc. qplot() and ggplot() (installed in the ggplot2 package) require some additional steps to format the spatial data but select colours and add keys etc automatically. Here, we are going to make use of the new tmap package which makes making maps very easy indeed. So one mega cool thing about R is you can read spatial data in straight from the internetz! Try this below for downloading a GeoJson file: EW &lt;- geojson_read(&quot;http://geoportal.statistics.gov.uk/datasets/8edafbe3276d4b56aec60991cbddda50_2.geojson&quot;, what = &quot;sp&quot;) #pull out london using grep and the regex wildcard for&#39;start of the string&#39; (^) to to look for the bit of the district code that relates to London (E09) from the &#39;lad15cd&#39; column in the data slot of our spatial polygons dataframe LondonMap &lt;- EW[grep(&quot;^E09&quot;,EW@data$lad15cd),] #plot it using the base plot function qtm(LondonMap) Of course, we can also read in our data from a shapefile stored in a local directory: #read the shapefile into a simple features object BoroughMapSF &lt;- read_shape(&quot;prac1_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp&quot;, as.sf = TRUE) BoroughMapSP &lt;- LondonMap #plot it very quickly usking qtm (quick thematic map) to check it has been read in correctly qtm(BoroughMapSF) qtm(BoroughMapSP) And naturally we can convert between simple features objects and spatialPolygonsDataFrames very easily: library(methods) #check the class of BoroughMapSF class(BoroughMapSF) ## [1] &quot;sf&quot; &quot;data.frame&quot; #And check the class of BoroughMapSP class(BoroughMapSP) ## [1] &quot;SpatialPolygonsDataFrame&quot; ## attr(,&quot;package&quot;) ## [1] &quot;sp&quot; #now convert the SP object into an SF object... newSF &lt;- st_as_sf(BoroughMapSP) #and try the other way around SF to SP... newSP &lt;- as(newSF, &quot;Spatial&quot;) #simples! BoroughMapSP &lt;- as(BoroughMapSF, &quot;Spatial&quot;) 1.3.7.4 Attribute data OK, enough messing around, show us the maps!! Hold your horses, before be can create a map, we need to join some attribute data to some boundaries. Doing this an SP object can be a bit of a pain, but I’ll show you here: #join the data to the @data slot in the SP data frame BoroughMapSP@data &lt;- data.frame(BoroughMapSP@data,LondonData[match(BoroughMapSP@data[,&quot;GSS_CODE&quot;],LondonData[,&quot;New.code&quot;]),]) #check it&#39;s joined. #head(BoroughMapSP@data) Joining data is a bit more intuitive with SF: BoroughDataMap &lt;- append_data(BoroughMapSF,LondonData, key.shp = &quot;GSS_CODE&quot;, key.data = &quot;New.code&quot;, ignore.duplicates = TRUE) ## Data contains duplicated keys: E09000001 ## Over coverage: 626 out of 659 data records were not appended. Run over_coverage() to get the corresponding data row numbers and key values. An alternative to append_data would be to use a left-join (like in SQL) BoroughDataMap2 &lt;- BoroughMapSF %&gt;% left_join(LondonData, by = c(&quot;GSS_CODE&quot; = &quot;New.code&quot;)) ## Warning: Column `GSS_CODE`/`New.code` joining factor and character vector, ## coercing into character vector However, you would need to remove the duplicate City of London row afterwards 1.3.7.5 Making some maps If you want to learn a bit more about the sorts of things you can do with tmap, then there are 2 vignettes that you can access here: https://cran.r-project.org/web/packages/tmap/ - I suggest you refer to these to see the various things you can do using tmap. Here’s a quick sample though: We can create a choropleth map very quickly now using qtm library(tmap) library(tmaptools) tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting qtm(BoroughDataMap, fill = &quot;Rate.of.JobSeekers.Allowance..JSA..Claimants...2015&quot;) You can also add a basemap and some other guff, if you wish… london_osm &lt;- read_osm(BoroughDataMap, type = &quot;esri&quot;, zoom = NULL) qtm(london_osm) + tm_shape(BoroughDataMap) + tm_polygons(&quot;Rate.of.JobSeekers.Allowance..JSA..Claimants...2015&quot;, style=&quot;jenks&quot;, palette=&quot;YlOrBr&quot;, midpoint=NA, title=&quot;Rate per 1,000 people&quot;, alpha = 0.5) + tm_compass(position = c(&quot;left&quot;, &quot;bottom&quot;),type = &quot;arrow&quot;) + tm_scale_bar(position = c(&quot;left&quot;, &quot;bottom&quot;)) + tm_layout(title = &quot;Job seekers&#39; Allowance Claimants&quot;, legend.position = c(&quot;right&quot;, &quot;bottom&quot;)) how about more than one map, perhaps using different data breaks… tm_shape(BoroughDataMap) + tm_polygons(c(&quot;Average.Public.Transport.Accessibility.score...2014&quot;, &quot;Violence.against.the.person.rate...2014.15&quot;), style=c(&quot;jenks&quot;, &quot;pretty&quot;), palette=list(&quot;YlOrBr&quot;, &quot;Purples&quot;), auto.palette.mapping=FALSE, title=c(&quot;Average Public Transport Accessibility&quot;, &quot;Violence Against the Person Rate&quot;)) ## Warning: The argument auto.palette.mapping is deprecated. Please use ## midpoint for numeric data and stretch.palette for categorical data to ## control the palette mapping. You will notice that to choose the colour of the maps, I entered some codes. These are the names of colour ramps from the RColourBrewer package which comes bundled with tmap. RColorBrewer uses colour palettes available from the colorbrewer2 website (http://colorbrewer2.org/) which is in turn based on the work of Cynthia Brewer and colleagues at Penn State University (http://www.personal.psu.edu/cab38/ColorBrewer/ColorBrewer_updates.html). Cynthia brewer has carried out large amount of academic research into determining the best colour palettes for GIS applications and so we will defer to her expertise here. If you want to look at the range of colour palettes available, as we; as going to the ColorBrewer website, you can use the a little shiny app which comes bundled with tmaptools #You might need to install the shinyjs paclage for this to work install.packages(&quot;shinyjs&quot;) library(shinyjs) #it&#39;s possible to explicitly tell R which package to get the function from with the :: operator... tmaptools::palette_explorer() tmap will even let you make a FRICKING INTERACTIVE MAP!!! Oh yes, we can do interactive maps…! tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(BoroughDataMap) + tm_polygons(&quot;X..children.in.year.6.who.are.obese..2011.12.to.2013.14&quot;, style=&quot;cont&quot;, palette=&quot;PuRd&quot;, midpoint=NA, title=&quot;Truffle Shuffle Intensity&quot;)+ tmap_options(max.categories = 5) ## Warning: Number of levels of the variable &quot;X..children.in.year. ## 6.who.are.obese..2011.12.to.2013.14&quot; is 31, which is larger ## than max.categories (which is 5), so levels are combined. Set ## tmap_options(max.categories = 31) in the layer function to show all levels. ####You can even save your map as an html file (uncomment, obvs) #save_tmap(filename = &quot;truffle.html&quot;) 1.3.7.6 Have a play around… There are loads of options for creating maps with tmap - read the vignettes that have been provided by the developers of the package and see if you can adapt the maps you have just made - or even make some alternative maps using built in data. https://cran.r-project.org/web/packages/tmap/vignettes/tmap-nutshell.html https://cran.r-project.org/web/packages/tmap/vignettes/tmap-modes.html You should also read the reference manual on the package homepage: https://cran.r-project.org/web/packages/tmap/ In fact, since I wrote this last year, the tmap package has developed quite a bit more - have a look at some of the cool examples here: https://github.com/mtennekes/tmap Have a play and see what cool shiz you can create! This is an example from the BubbleMap folder on the tmap github. Don’t worry about what github is we will cover that soon. # load spatial data included in the tmap package data(&quot;World&quot;, &quot;metro&quot;) # calculate annual growth rate metro$growth &lt;- (metro$pop2020 - metro$pop2010) / (metro$pop2010 * 10) * 100 # plot tm_shape(World) + tm_polygons(&quot;income_grp&quot;, palette = &quot;-Blues&quot;, title = &quot;Income class&quot;, contrast = 0.7, border.col = &quot;gray30&quot;, id = &quot;name&quot;) + tm_text(&quot;iso_a3&quot;, size = &quot;AREA&quot;, col = &quot;gray30&quot;, root=3) + tm_shape(metro) + tm_bubbles(&quot;pop2010&quot;, col = &quot;growth&quot;, border.col = &quot;black&quot;, border.alpha = 0.5, breaks = c(-Inf, 0, 2, 4, 6, Inf) , palette = &quot;-RdYlGn&quot;, title.size = &quot;Metro population (2010)&quot;, title.col = &quot;Annual growth rate (%)&quot;, id = &quot;name&quot;, popup.vars=c(&quot;pop2010&quot;, &quot;pop2020&quot;, &quot;growth&quot;)) + tm_format(&quot;World&quot;) + tm_style(&quot;gray&quot;) 1.4 Making maps using ggplot2 So as you have seen, it is possible to make very nice thematic maps with tmap. However, there are other options. The ggplot2 package is a very powerful graphics package that allows us to a huge range of sophisticated plots, including maps. The latest development version of ggplot2 has support for simple features objects with the new geom_sf class (http://ggplot2.tidyverse.org/reference/ggsf.html), which, quite frankly, is bloody brilliant! If you have not already done so, install and library the ggplot2 and rgeos packages (they should be installed automatically as part of tidyverse and tmap packages, but occasionally they need to be installed separately). Now there are two main ways in which you can construct a plot in ggplot2: qplot() and ggplot(). qplot is short for ‘Quick plot’ and can be good for producing quick charts and maps, but is perhaps less good for constructing complex layered plots. ggplot() is better for building up a plot layer by layer, e.g. ggplot()+layer1+layer2, and so this is what we will use here. The important elements of any ggplot layer are the aesthetic mappings – aes(x,y, …) – which tell ggplot where to place the plot objects. We can imagine a map just like a graph with all features mapping to an x and y axis. All geometry ( geom_) types in ggplot feature some kind of aesthetic mapping and these can either be declared at the plot level, e.g. ggplot(data.frame, aes(x=x, y=y)) or, more flexibly at the level of the individual geom_ layer, e.g. geom_polygon(aes(x=x, y=y), data.frame) To begin our plot, we will start with the map layer – we will generate this using the geom_sf() function in ggplot2: ggplot()+geom_sf(mapping = aes(geometry=geometry),data = BoroughDataMap)+theme_minimal() To colour your map, then just pass the name of the variable you want to map to the fill parameter in the aesthetics: ggplot()+geom_sf(mapping = aes(geometry=geometry, fill=Median.House.Price...U.00A3.....2014),data = BoroughDataMap)+theme_minimal() As you can see, this map looks OK, but there are a few issues with things like the colour ramp and a lack of appropriate labels. We can correct this by adding a few more layers. Firstly we can change the palette: palette1&lt;-scale_fill_continuous(low=&quot;white&quot;, high=&quot;orange&quot;, &quot;Price(£)&quot;) And some appropriate labels: labels&lt;-labs(title=&quot;Average House Price 2014&quot;,x=&quot;Longitude&quot;, y=&quot;Latitude&quot;) Before plotting the all of them together: ggplot()+geom_sf(mapping = aes(geometry=geometry, fill=Median.House.Price...U.00A3.....2014),data = BoroughDataMap)+theme_minimal()+palette1+labels 1.4.1 Changing projections Now until now, we’ve not really considered how our maps have been printed to the screen. The coordinates stored in the geometry column of your sf object contain the information to enable points, lines or polygons to be drawn on the screen (think back to the KML exercise in week 1). The ggplot map above could fool you into thinking the coordinate system we are using is latitude and longitude, but actually, the map coordinates are stored in British National Grid. How can we tell? You can check that the coordinate reference systems of sf or sp objects using the print function: print(BoroughMapSP) ## class : SpatialPolygonsDataFrame ## features : 33 ## extent : 503568.2, 561957.5, 155850.8, 200933.9 (xmin, xmax, ymin, ymax) ## crs : +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.999601272 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.1502,0.247,0.8421,-20.4894 +units=m +no_defs ## variables : 74 ## names : NAME, GSS_CODE, HECTARES, NONLD_AREA, ONS_INNER, SUB_2009, SUB_2006, Ward.name, Old.code, New.code, Population...2015, Children.aged.0.15...2015, Working.age..16.64....2015, Older.people.aged.65....2015, X..All.Children.aged.0.15...2015, ... ## min values : Barking and Dagenham, E09000001, 314.942, 0, F, NA, NA, Barking and Dagenham, 00AA, E09000001, 8100, 650, 6250, 1250, 8, ... ## max values : Westminster, E09000033, 15013.487, 370.619, T, NA, NA, Westminster, 00BK, E09000033, 393200, 82900, 257850, 56550, 26.1, ... print(BoroughMapSF) ## Simple feature collection with 33 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## epsg (SRID): NA ## proj4string: +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.999601272 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.1502,0.247,0.8421,-20.4894 +units=m +no_defs ## First 10 features: ## NAME GSS_CODE HECTARES NONLD_AREA ONS_INNER SUB_2009 ## 0 Kingston upon Thames E09000021 3726.117 0.000 F &lt;NA&gt; ## 1 Croydon E09000008 8649.441 0.000 F &lt;NA&gt; ## 2 Bromley E09000006 15013.487 0.000 F &lt;NA&gt; ## 3 Hounslow E09000018 5658.541 60.755 F &lt;NA&gt; ## 4 Ealing E09000009 5554.428 0.000 F &lt;NA&gt; ## 5 Havering E09000016 11445.735 210.763 F &lt;NA&gt; ## 6 Hillingdon E09000017 11570.063 0.000 F &lt;NA&gt; ## 7 Harrow E09000015 5046.330 0.000 F &lt;NA&gt; ## 8 Brent E09000005 4323.270 0.000 F &lt;NA&gt; ## 9 Barnet E09000003 8674.837 0.000 F &lt;NA&gt; ## SUB_2006 geometry ## 0 &lt;NA&gt; MULTIPOLYGON (((516401.6 16... ## 1 &lt;NA&gt; MULTIPOLYGON (((535009.2 15... ## 2 &lt;NA&gt; MULTIPOLYGON (((540373.6 15... ## 3 &lt;NA&gt; MULTIPOLYGON (((521975.8 17... ## 4 &lt;NA&gt; MULTIPOLYGON (((510253.5 18... ## 5 &lt;NA&gt; MULTIPOLYGON (((549893.9 18... ## 6 &lt;NA&gt; MULTIPOLYGON (((510599.8 19... ## 7 &lt;NA&gt; MULTIPOLYGON (((510599.8 19... ## 8 &lt;NA&gt; MULTIPOLYGON (((525201 1825... ## 9 &lt;NA&gt; MULTIPOLYGON (((524579.9 19... 1.4.1.1 Proj4 If you’re a spatial geek and you’re used to looking at London, then a quick glance at the values of the extent / bounding box (bbox) will tell you that you are working in British National Grid as the x and y values are in 6 Figures, with x values around 52000 to 55000 and y values around 15000 to 20000. The other way of telling is by looking at the coordinate reference system (CRS) value - in the files above it’s defined by the bit that says: +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy “Well that’s clear as mud!” I hear you cry! Yes, not obvious is it! This is called a proj-string or proj4-string and its the proj4-string for British National Grid. You can learn what each of the bits of this mean here: https://proj4.org/usage/quickstart.html The proj4-string basically tells the computer where on the earth to locate the coordinates that make up the geometries in your file and what distortions to apply (i.e. if to flatten it out completely etc.) Sometimes you can download data from the web and it doesn’t have a CRS . If any boundary data you download does not have a coordinate reference system attached to it (NA is displayed in the coord. ref section), this is not a huge problem - it can be added afterwards by adding the proj4string to the file. To find the proj4-strings for a whole range of different geographic projections, use the search facility at http://spatialreference.org/ or http://epsg.io/. 1.4.1.2 EPSG Now, if you can store a whole proj4-string in your mind, you must be some kind of savant (why are you doing this course? you could make your fortune as a card-counting poker player or something!). The rest of us need something a little bit more easy to remember and for coordinate reference systems, the saviour is the European Petroleum Survey Group (EPSG) - (naturally!). Now managed and maintained by the International Association of Oil and Gas producers - http://www.epsg.org/ - EPSG codes are short numbers represent all coordinate reference systems in the world and link directly to proj4 strings. The EPSG code for British National Grid is 27700 - http://epsg.io/27700. The EPSG code for the WGS84 World Geodetic System (usually the default CRS for most spatial data) is 4326 - http://epsg.io/4326 If your boundary data doesn’t have a spatial reference system, you can read it in you can read it in and set the projection either with the full proj4 string, or, more easily, with the EPSG code: # read borough map in and explicitly set projection to British National Grid # using the EPSG string code 27700 BoroughMapSP &lt;- read_shape(&quot;prac1_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp&quot;, current.projection = 27700) ## Warning: Projection already specified in shape file. Use set_projection for ## reprojection. #or, for SF BoroughMapSF &lt;- st_read(&quot;prac1_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp&quot;) %&gt;% st_set_crs(27700) ## Reading layer `London_Borough_Excluding_MHW&#39; from data source `N:\\Documents\\Teaching\\CASA0005practicals\\CASA0005repo\\prac1_data\\statistical-gis-boundaries-london\\ESRI\\London_Borough_Excluding_MHW.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 33 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## epsg (SRID): NA ## proj4string: +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.999601272 +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs ## Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform ## for that Another option is to assign the coordinates reference system after the shapefile has been read in, for example. However as we have already assigned a CRS to BoroughMapSP R in the function read_shape R will through an error. So let’s read the shape again using readOGR from the rgdal package: BoroughMapSP &lt;- readOGR(&quot;prac1_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;N:\\Documents\\Teaching\\CASA0005practicals\\CASA0005repo\\prac1_data\\statistical-gis-boundaries-london\\ESRI\\London_Borough_Excluding_MHW.shp&quot;, layer: &quot;London_Borough_Excluding_MHW&quot; ## with 33 features ## It has 7 fields #create a variable for the EPSG code to reference the proj4string (EPSG codes are shorter and easier to remember than the full strings!) and store it in a variable... UKBNG &lt;- &quot;+init=epsg:27700&quot; #now set the proj4string for your BoroughMap object - note, this will probably throw an error if your dataset already has a CRS, this is just for demonstration... proj4string(BoroughMapSP) &lt;- CRS(UKBNG) print(BoroughMapSP) # check for new CRS ## class : SpatialPolygonsDataFrame ## features : 33 ## extent : 503568.2, 561957.5, 155850.8, 200933.9 (xmin, xmax, ymin, ymax) ## crs : +init=epsg:27700 +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs +ellps=airy +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894 ## variables : 7 ## names : NAME, GSS_CODE, HECTARES, NONLD_AREA, ONS_INNER, SUB_2009, SUB_2006 ## min values : Barking and Dagenham, E09000001, 314.942, 0, F, NA, NA ## max values : Westminster, E09000033, 15013.487, 370.619, T, NA, NA or for SF: BoroughMapSF &lt;- BoroughMapSF %&gt;% st_set_crs(27700) print(BoroughMapSF) ## Simple feature collection with 33 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9 ## epsg (SRID): 27700 ## proj4string: +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs ## First 10 features: ## NAME GSS_CODE HECTARES NONLD_AREA ONS_INNER SUB_2009 ## 1 Kingston upon Thames E09000021 3726.117 0.000 F &lt;NA&gt; ## 2 Croydon E09000008 8649.441 0.000 F &lt;NA&gt; ## 3 Bromley E09000006 15013.487 0.000 F &lt;NA&gt; ## 4 Hounslow E09000018 5658.541 60.755 F &lt;NA&gt; ## 5 Ealing E09000009 5554.428 0.000 F &lt;NA&gt; ## 6 Havering E09000016 11445.735 210.763 F &lt;NA&gt; ## 7 Hillingdon E09000017 11570.063 0.000 F &lt;NA&gt; ## 8 Harrow E09000015 5046.330 0.000 F &lt;NA&gt; ## 9 Brent E09000005 4323.270 0.000 F &lt;NA&gt; ## 10 Barnet E09000003 8674.837 0.000 F &lt;NA&gt; ## SUB_2006 geometry ## 1 &lt;NA&gt; MULTIPOLYGON (((516401.6 16... ## 2 &lt;NA&gt; MULTIPOLYGON (((535009.2 15... ## 3 &lt;NA&gt; MULTIPOLYGON (((540373.6 15... ## 4 &lt;NA&gt; MULTIPOLYGON (((521975.8 17... ## 5 &lt;NA&gt; MULTIPOLYGON (((510253.5 18... ## 6 &lt;NA&gt; MULTIPOLYGON (((549893.9 18... ## 7 &lt;NA&gt; MULTIPOLYGON (((510599.8 19... ## 8 &lt;NA&gt; MULTIPOLYGON (((510599.8 19... ## 9 &lt;NA&gt; MULTIPOLYGON (((525201 1825... ## 10 &lt;NA&gt; MULTIPOLYGON (((524579.9 19... 1.4.1.3 Reprojecting your spatial data Reprojecting your data is something that you might have to (or want to) do, on occasion. Why? Well, one example might be if you want to measure the distance of a line object, or the distance between two polygons. This can be done far more easily in a projected coordinate system like British National Grid (where the units are measured in metres) than it can a geographic coordinate system such as WGS84 (where the units are degrees). For generating maps in packages like leaflet, your maps will also need to be in WGS84, rather than British National Grid. So once your data has a coordinates system to work with, we can re-project or transform to anything we like. The most commonly used is the global latitude and longitude system (WGS84). With SP objects, this is carried out using the spTransform() function: BoroughMapSPWGS84 &lt;-spTransform(BoroughMapSP, CRS(&quot;+proj=longlat +datum=WGS84&quot;)) print(BoroughMapSPWGS84) ## class : SpatialPolygonsDataFrame ## features : 33 ## extent : -0.5103751, 0.3340155, 51.28676, 51.69187 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 ## variables : 7 ## names : NAME, GSS_CODE, HECTARES, NONLD_AREA, ONS_INNER, SUB_2009, SUB_2006 ## min values : Barking and Dagenham, E09000001, 314.942, 0, F, NA, NA ## max values : Westminster, E09000033, 15013.487, 370.619, T, NA, NA #transform it back again: BoroughMapSPBNG &lt;-spTransform(BoroughMapSP, CRS(UKBNG)) print(BoroughMapSPBNG) ## class : SpatialPolygonsDataFrame ## features : 33 ## extent : 503568.2, 561957.5, 155850.8, 200933.9 (xmin, xmax, ymin, ymax) ## crs : +init=epsg:27700 +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs +ellps=airy +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894 ## variables : 7 ## names : NAME, GSS_CODE, HECTARES, NONLD_AREA, ONS_INNER, SUB_2009, SUB_2006 ## min values : Barking and Dagenham, E09000001, 314.942, 0, F, NA, NA ## max values : Westminster, E09000033, 15013.487, 370.619, T, NA, NA #You may want to create a similar variable for WGS84 latlong &lt;- &quot;+init=epsg:4326&quot; And for SF objects it’s carried out using st_transform: BoroughMapSFWGS84 &lt;- st_transform(BoroughMapSF, 4326) print(BoroughMapSFWGS84) ## Simple feature collection with 33 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -0.5103751 ymin: 51.28676 xmax: 0.3340156 ymax: 51.69187 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## First 10 features: ## NAME GSS_CODE HECTARES NONLD_AREA ONS_INNER SUB_2009 ## 1 Kingston upon Thames E09000021 3726.117 0.000 F &lt;NA&gt; ## 2 Croydon E09000008 8649.441 0.000 F &lt;NA&gt; ## 3 Bromley E09000006 15013.487 0.000 F &lt;NA&gt; ## 4 Hounslow E09000018 5658.541 60.755 F &lt;NA&gt; ## 5 Ealing E09000009 5554.428 0.000 F &lt;NA&gt; ## 6 Havering E09000016 11445.735 210.763 F &lt;NA&gt; ## 7 Hillingdon E09000017 11570.063 0.000 F &lt;NA&gt; ## 8 Harrow E09000015 5046.330 0.000 F &lt;NA&gt; ## 9 Brent E09000005 4323.270 0.000 F &lt;NA&gt; ## 10 Barnet E09000003 8674.837 0.000 F &lt;NA&gt; ## SUB_2006 geometry ## 1 &lt;NA&gt; MULTIPOLYGON (((-0.330679 5... ## 2 &lt;NA&gt; MULTIPOLYGON (((-0.0640212 ... ## 3 &lt;NA&gt; MULTIPOLYGON (((0.01213098 ... ## 4 &lt;NA&gt; MULTIPOLYGON (((-0.2445624 ... ## 5 &lt;NA&gt; MULTIPOLYGON (((-0.4118326 ... ## 6 &lt;NA&gt; MULTIPOLYGON (((0.1586929 5... ## 7 &lt;NA&gt; MULTIPOLYGON (((-0.4040719 ... ## 8 &lt;NA&gt; MULTIPOLYGON (((-0.4040719 ... ## 9 &lt;NA&gt; MULTIPOLYGON (((-0.1965687 ... ## 10 &lt;NA&gt; MULTIPOLYGON (((-0.1998964 ... In the SF object, you can compare the values in the geometry column with those in the original file to look at how they have changed… 1.4.2 Maps with extra features Now we can re-project our data, it frees us up to bring in, for example, different base maps and other stuff, a bit like tmap. #install.packages(&quot;ggmap&quot;) library(ggmap) BoroughDataMap &lt;- append_data(BoroughMapSFWGS84,LondonData, key.shp = &quot;GSS_CODE&quot;, key.data = &quot;New.code&quot;, ignore.duplicates = TRUE) londonbbox1 &lt;- c(left = -0.5103766, bottom = 51.28676, right = 0.3340146, top = 51.69187) londonbbox2 &lt;- as.vector(st_bbox(BoroughMapSFWGS84)) #this bit of code uses the box we specified and gets map tiles from Stamen Maps (http://maps.stamen.com/#terrain/12/37.7706/-122.3782) # try changing the maptype to watercolor map &lt;- get_stamenmap(londonbbox2, zoom = 10, maptype = &quot;toner-lite&quot;) ggmap(map) + geom_sf(mapping = aes(geometry=geometry, fill=Median.House.Price...U.00A3.....2014),data = BoroughDataMap, inherit.aes = FALSE,alpha=0.7)+theme_minimal()+palette1+labels 1.4.3 Extension 1.4.3.1 Faceted plots One of the nice features of ggplot2 is its faceting function which allows you to lay out subsets of your data in different panels of a grid. See if you can create a faceted grid of London maps like the one shown below. To do this, you will need to go through several stages: You will need to subset your Borough_geom data frame so that it only contains data on the same scale (you have a number of columns that show percentages, for example) – you can show facets on different scales, but we will leave this for the time being. You will also need to make sure your subset includes a few columns of key ID information data at the beginning – e.g. ID and geometry. You will then need to use the reshape2 package to reformat your data using the melt() function, with an argument to specify the columns where your ID data ends (all columns afterwards containing data you want to plot). A call something like: #warning, this is messy, but it sort-of works... library(reshape2) ## ## Attaching package: &#39;reshape2&#39; ## The following object is masked from &#39;package:tidyr&#39;: ## ## smiths library(dplyr) #use melt to bung all of the variables into a single column on top of each other, but leave out the geometry column or it will throw an error. Make sure you know which coloumn holds the geometry.I&#39;m only going to select 10 coloumns of data here (measure.vars=10:20). borough_melt &lt;- melt(BoroughDataMap,id.vars = 1:9, measure.vars = 10:20) #have a look at borough_melt now - in this circumstance i find the best way is to click on the data in the enviroment window (top right), what do you notice? #now join the geometry column back on - you will have to join it along with all of the data again. borough_melt &lt;- left_join(borough_melt,BoroughDataMap,by = c(&quot;GSS_CODE&quot; = &quot;GSS_CODE&quot;)) #here i&#39;m removing everything except the variable coloumn, values and the geometry inforamtion borough_melt &lt;- borough_melt[,c(10:11,84)] library(tmap) library(sf) library(maptools) tmap_mode(&quot;plot&quot;) ## tmap mode set to plotting borough_melt &lt;- st_as_sf(borough_melt) qtm(borough_melt, fill = &quot;value&quot;, by = &quot;variable&quot;) or, indeed, in ggplot2 like this: ggplot()+geom_sf(mapping = aes(geometry=geometry, fill=value),data = borough_melt)+facet_wrap(~variable) 1.4.3.2 Interactive web maps So we created an interactive map with tmap earlier and that was pretty cool, but if we want to do even more mind-blowing stuff later on in the course, we will need to get our heads around how to do interactive maps using leaflet. Leaflet is a Java Script library for producing interactive web maps, and some enterprising coders over at RStudio have produced a package for allowing you to create your own Leaflet maps. All of the documentation for the R Leaflet package can be found here: https://rstudio.github.io/leaflet/ library(leaflet) library(sf) library(sp) library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:ggmap&#39;: ## ## inset ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract library(classInt) 1.4.3.2.1 Generating a colour ramp and palette Before we create a leaflet map, we need to specify what the breaks in our data are going to be… colours&lt;- brewer.pal(5, &quot;Blues&quot;) breaks&lt;-classIntervals(BoroughDataMap$Claimant.Rate.of.Housing.Benefit..2015., n=5, style=&quot;jenks&quot;) graphics::plot(breaks, pal=colours) So we have now created a breaks object which uses the jenks natural breaks algorithm to divide up our variable into 5 classes. You will notice that breaks is a list of 2 objects. We want only the brks bit which contains the values for the breaks summary(breaks) ## Length Class Mode ## var 33 -none- numeric ## brks 6 -none- numeric breaks &lt;- as.numeric(breaks$brks) Now we can create out leaflet interactive map. Here you will see that I am using different syntax to that which has gone before. The %&gt;% (pipe) operator is part of the magrittr package - https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html. magrittr is an entirely new way of thinking about R syntax. Read up on it if you wish, but for now it is useful to think of the pipe operator as simply meaning “then”. Do this THEN do this THEN do that. #create a new sp object from the earlier sf object with all of our data in THEN Transform it to WGS84 THEN convert it to SP. BoroughDataMapSP &lt;- BoroughDataMap %&gt;% st_transform(crs = 4326) %&gt;% as(&quot;Spatial&quot;) #create a colour palette using colorBin colour mapping pal &lt;- colorBin(palette = &quot;YlOrRd&quot;, domain = BoroughDataMapSP$Claimant.Rate.of.Housing.Benefit..2015., #create bins using the breaks object from earlier bins = breaks) # now, add some polygons colour them using your colour palette, #overlay the, on top of a nice backdrop and add a legend. Note the #use of the magrittr pipe operator (%&gt;%) – check the documentation #to understand how this is working… leaflet(BoroughDataMapSP) %&gt;% addPolygons(stroke = FALSE, fillOpacity = 0.5, smoothFactor = 0.5, color = ~pal(Claimant.Rate.of.Housing.Benefit..2015.), popup = ~NAME ) %&gt;% addProviderTiles(&quot;CartoDB.DarkMatter&quot;) %&gt;% addLegend(&quot;bottomright&quot;, pal= pal, values = ~Claimant.Rate.of.Housing.Benefit..2015., title = &quot;Housing Benefit Claimant Rate&quot;, labFormat = labelFormat(prefix = &quot;Per 1,000 people &quot;), opacity = 1 ) "],
["rasters-descriptive-statistics-and-interpolation.html", "Chapter 2 Rasters, descriptive statistics and interpolation 2.1 Learning outcomes 2.2 Introduction 2.3 Part 1 rasters 2.4 Part 2 descriptive statistics 2.5 Part 3 interpolation 2.6 Auto data download 2.7 Advanced analysis", " Chapter 2 Rasters, descriptive statistics and interpolation 2.1 Learning outcomes By the end of this practical you should be able to: Load, manipulate and interpret raster layers Observe and critique different descriptive data manipulation methods and outputs Exceute interpolation of points to a raster layer Construct a methodology for comparing raster datasets 2.2 Introduction This practical is composed of three parts. To start with we’re going to load some global raster data into R. In the second part we extract data points (cities and towns) from this data and generate some descriptive statistics and histograms. In the final section we explore interpolation using point data. 2.3 Part 1 rasters So far we’ve only really considered vector data. Within this practical we will explore some raster data sources and processing techniques. If you recall rasters are grids of cell with individual values. There are many, many possible sources to obtain raster data from as it is the data type used for the majority (basically all) of remote sensing data. 2.3.1 WorldClim data To start with we are going to use WorldClim data — this is a dataset of free global climate layers (rasters) with a spatial resolution of between 1\\(km^2\\) and 240\\(km^2\\). Download the data from: http://worldclim.org/version2 Select any variable you want at the 5 minute second resolution. What is a 5 minute resolution i hear you ask? Well, this geographic reference system treats the globe as if it was a sphere divided into 360 equal parts called degrees. Each degree has 60 minutes and each minute has 60 seconds. Arc-seconds of latitude remain almost constant whilst arc-seconds of longitude decrease in a trigonometric cosine-based fashion as you move towards the Earth’s poles…. If you are still a bit confused by coordiate reference systems have a look at the following: * https://communityhub.esriuk.com/geoxchange/2012/3/26/coordinate-systems-and-projections-for-beginners.html * https://en.wikipedia.org/wiki/Spatial_reference_system Unzip and move the data to your project folder. Now load the data. We could do this individually…. library(raster) jan=raster(&quot;prac3_data/wc2.0_5m_tavg_01.tif&quot;) # have a look at the raster layer jan jan ## class : RasterLayer ## dimensions : 2160, 4320, 9331200 (nrow, ncol, ncell) ## resolution : 0.08333333, 0.08333333 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : N:/Documents/Teaching/CASA0005practicals/CASA0005repo/prac3_data/wc2.0_5m_tavg_01.tif ## names : wc2.0_5m_tavg_01 ## values : -46.697, 34.291 (min, max) Then have a quick look at the data plot(jan) A better and more efficient way is to firstly list all the files stored within our directory listfiles &lt;- list.files(&quot;prac3_data&quot;, &quot;.tif&quot;, full.names=TRUE) #have a look at the file names listfiles ## [1] &quot;prac3_data/wc2.0_5m_tavg_01.tif&quot; &quot;prac3_data/wc2.0_5m_tavg_02.tif&quot; ## [3] &quot;prac3_data/wc2.0_5m_tavg_03.tif&quot; &quot;prac3_data/wc2.0_5m_tavg_04.tif&quot; ## [5] &quot;prac3_data/wc2.0_5m_tavg_05.tif&quot; &quot;prac3_data/wc2.0_5m_tavg_06.tif&quot; ## [7] &quot;prac3_data/wc2.0_5m_tavg_07.tif&quot; &quot;prac3_data/wc2.0_5m_tavg_08.tif&quot; ## [9] &quot;prac3_data/wc2.0_5m_tavg_09.tif&quot; &quot;prac3_data/wc2.0_5m_tavg_10.tif&quot; ## [11] &quot;prac3_data/wc2.0_5m_tavg_11.tif&quot; &quot;prac3_data/wc2.0_5m_tavg_12.tif&quot; Then load all of the data straight into a raster stack. A raster stack is a collection of raster layers with the same spatial extent and resolution. worldclimtemp &lt;- stack(listfiles) #have a look at the raster stack worldclimtemp ## class : RasterStack ## dimensions : 2160, 4320, 9331200, 12 (nrow, ncol, ncell, nlayers) ## resolution : 0.08333333, 0.08333333 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## names : wc2.0_5m_tavg_01, wc2.0_5m_tavg_02, wc2.0_5m_tavg_03, wc2.0_5m_tavg_04, wc2.0_5m_tavg_05, wc2.0_5m_tavg_06, wc2.0_5m_tavg_07, wc2.0_5m_tavg_08, wc2.0_5m_tavg_09, wc2.0_5m_tavg_10, wc2.0_5m_tavg_11, wc2.0_5m_tavg_12 ## min values : -46.697, -44.559, -57.107, -62.996, -63.541, -63.096, -66.785, -64.600, -62.600, -54.400, -42.000, -45.340 ## max values : 34.291, 33.174, 33.904, 34.629, 36.312, 38.400, 43.036, 41.073, 36.389, 33.869, 33.518, 33.667 In the raster stack you’ll notice that under dimensions there are 12 layers (nlayers). The stack has loaded the 12 months of average temperature data for us in order. To access single layers within the stack: # access the january layer worldclimtemp[[1]] ## class : RasterLayer ## dimensions : 2160, 4320, 9331200 (nrow, ncol, ncell) ## resolution : 0.08333333, 0.08333333 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : N:/Documents/Teaching/CASA0005practicals/CASA0005repo/prac3_data/wc2.0_5m_tavg_01.tif ## names : wc2.0_5m_tavg_01 ## values : -46.697, 34.291 (min, max) We can also rename our layers within the stack: month &lt;- c(&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;) names(worldclimtemp) &lt;- month Now to get data for just January use our new layer name worldclimtemp$Jan ## class : RasterLayer ## dimensions : 2160, 4320, 9331200 (nrow, ncol, ncell) ## resolution : 0.08333333, 0.08333333 (x, y) ## extent : -180, 180, -90, 90 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : N:/Documents/Teaching/CASA0005practicals/CASA0005repo/prac3_data/wc2.0_5m_tavg_01.tif ## names : Jan ## values : -46.697, 34.291 (min, max) 2.3.2 Location data from a raster Using a raster stack we can extract data with a single command!! For example let’s make a dataframe of some sample sites — Australian cities/towns. site &lt;- c(&quot;Brisbane&quot;, &quot;Melbourne&quot;, &quot;Perth&quot;, &quot;Sydney&quot;, &quot;Broome&quot;, &quot;Darwin&quot;, &quot;Orange&quot;, &quot;Bunbury&quot;, &quot;Cairns&quot;, &quot;Adelaide&quot;, &quot;Gold Coast&quot;, &quot;Canberra&quot;, &quot;Newcastle&quot;, &quot;Wollongong&quot;, &quot;Logan City&quot; ) lon &lt;- c(153.03, 144.96, 115.86, 151.21, 122.23, 130.84, 149.10, 115.64, 145.77, 138.6, 153.43, 149.13, 151.78, 150.89, 153.12) lat &lt;- c(-27.47, -37.91, -31.95, -33.87, 17.96, -12.46, -33.28, -33.33, -16.92, -34.93, -28, -35.28, -32.93, -34.42, -27.64) #Put all of this inforamtion into one list samples &lt;- data.frame(site, lon, lat, row.names=&quot;site&quot;) # Extract the data from the Rasterstack for all points AUcitytemp&lt;- extract(worldclimtemp, samples) Add the city names to the rows of AUcitytemp row.names(AUcitytemp)&lt;-site 2.4 Part 2 descriptive statistics Descriptive statistics provide a summary of our data, often forming the base of quantitiatve analysis leading to inferential statistics which we use to make infereces about our data (e.g. judegements of the probability that the observed difference between two datasets is not by chance) 2.4.1 Data preparation Let’s take Perth as an example. We can subset our data either using the row name: Perthtemp &lt;- subset(AUcitytemp, rownames(AUcitytemp) == &quot;Perth&quot;) Or the row location: Perthtemp &lt;- AUcitytemp[3,] 2.4.2 Histogram A histogram lets us see the frequency of distribution of our data. Make a histogram of Perth’s temperature hist(Perthtemp) Remember what we’re looking at here. The x axis is the temperature and the y is the frequency of occurrence. That’s a pretty simple histogram, let’s improve the aesthetics a bit. #define where you want the breaks in the historgram userbreak&lt;-c(8,10,12,14,16,18,20,22,24,26) hist(Perthtemp, breaks=userbreak, col=&quot;red&quot;, main=&quot;Histogram of Perth Temperature&quot;, xlab=&quot;Temperature&quot;, ylab=&quot;Frequency&quot;) Check out the histogram information R generated histinfo&lt;-hist(Perthtemp) histinfo ## $breaks ## [1] 12 14 16 18 20 22 24 26 ## ## $counts ## [1] 1 3 2 2 1 1 2 ## ## $density ## [1] 0.04166667 0.12500000 0.08333333 0.08333333 0.04166667 0.04166667 ## [7] 0.08333333 ## ## $mids ## [1] 13 15 17 19 21 23 25 ## ## $xname ## [1] &quot;Perthtemp&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; Here we have: breaks — the cut off points for the bins (or bars), we just specified these counts — the number of cells in each bin midpoints — the middle value for each bin density — the density of data per bin 2.4.3 Using more data This was still a rather basic histogram, what if we wanted to see the distribution of temperatures for the whole of Australia in Jan (from averaged WorldClim data) as opposed to just our point for Perth. First, we need to source and load a vector of Australia. Go to: https://gadm.org/download_country_v3.html and download the GeoPackage Check what layers are within a Geo package using: library(sf) st_layers(&quot;prac3_data/gadm36_AUS.gpkg&quot;) ## Driver: GPKG ## Available layers: ## layer_name geometry_type features fields ## 1 gadm36_AUS_0 Multi Polygon 1 2 ## 2 gadm36_AUS_1 Multi Polygon 11 10 ## 3 gadm36_AUS_2 Multi Polygon 569 13 Then read in the GeoPackage layer for the whole of Australia Ausoutline &lt;- st_read(&quot;prac3_data/gadm36_AUS.gpkg&quot;, layer=&#39;gadm36_AUS_0&#39;) ## Reading layer `gadm36_AUS_0&#39; from data source `N:\\Documents\\Teaching\\CASA0005practicals\\CASA0005repo\\prac3_data\\gadm36_AUS.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 1 feature and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 112.9211 ymin: -55.11694 xmax: 159.1092 ymax: -9.142176 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs #Check the layer by plotting the geometry plot(Ausoutline$geom) Next, set our map extent to the outline of Australia then crop our WorldClim dataset to it Ausarea &lt;- extent(Ausoutline) # check the extent Ausarea ## class : Extent ## xmin : 112.9211 ## xmax : 159.1092 ## ymin : -55.11694 ## ymax : -9.142176 # now crop our temp data to the extent Austemp &lt;- crop(worldclimtemp, Ausoutline) # plot the output Austemp ## class : RasterBrick ## dimensions : 551, 554, 305254, 12 (nrow, ncol, ncell, nlayers) ## resolution : 0.08333333, 0.08333333 (x, y) ## extent : 112.9167, 159.0833, -55.08333, -9.166667 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec ## min values : 6.360000, 6.287500, 5.554286, 4.051429, 2.542857, -0.171000, -1.945000, -1.677000, 0.677000, 3.054286, 3.842424, 5.433333 ## max values : 34.29100, 33.17400, 32.39700, 30.07200, 28.50000, 27.40000, 26.90000, 27.20000, 29.31209, 31.72000, 33.51800, 33.66700 You’ll notice that whilst we have the whole of Australia the raster hasn’t been perfectly clipped to the exact outline….the extent just specifies an extent box that will cover the whole of the shape. If want to just get raster data within the outline of the shape: exactAus=mask(Austemp, Ausoutline, na.rm=TRUE) You could also run this using the original worldclimtemp raster, however, it may take some time. I’d recommend cropping to the extent first. Both our Austemp and exactAus are raster bricks. A brick is similar to a stack except it is now stored as one file instead of a collection. Let’s re-compute our histogram for Australia in March. We could just use hist like we have done before hist(exactAus[[3]], col=&quot;red&quot;, main =&quot;March temperature&quot;) However we have a bit more control with ggplot… 2.4.4 Histogram with ggplot We need to make our raster into a data.frame to be compatible with ggplot2 alldf=as.data.frame(exactAus) library(ggplot2) gghist &lt;- ggplot(alldf, aes(x=Mar)) + geom_histogram(color=&quot;black&quot;, fill=&quot;white&quot;)+ labs(title=&quot;Ggplot2 histogram of Australian March temperatures&quot;, x=&quot;Temperature&quot;, y=&quot;Frequency&quot;) gghist + geom_vline(aes(xintercept=mean(Mar, na.rm=TRUE)), color=&quot;blue&quot;, linetype=&quot;dashed&quot;, size=1)+ theme(plot.title = element_text(hjust = 0.5)) How about plotting multiple months of temperature data on the same histogram As we did in practical 2, we need to put our variaible (months) into a one coloumn using melt. We will do this based on the names of our coloumns in alldf… library(reshape2) squishdata &lt;- melt(alldf, measure.vars=names(alldf)) Then subset the data, selecting two months twomonths&lt;-subset(squishdata, variable==&quot;Jan&quot; | variable==&quot;Jun&quot;) Get the mean for each month we selected library(plyr) meantwomonths &lt;- ddply(twomonths, &quot;variable&quot;, summarise, grp.mean=mean(value, na.rm=TRUE)) colnames(meantwomonths)[colnames(meantwomonths)==&quot;variable&quot;] &lt;- &quot;Month&quot; head(meantwomonths) ## Month grp.mean ## 1 Jan 28.11321 ## 2 Jun 14.96415 Select the colour (here color in the code — US english) and fill based on the variable (which is our month). The intercept is the mean we just calculated, with the lines also based on the coloumn variable. #rename the coloumn from variable to month so it looks nice in the legend of the histogram colnames(twomonths)[colnames(twomonths)==&quot;variable&quot;] &lt;- &quot;Month&quot; ggplot(twomonths, aes(x=value, color=Month, fill=Month)) + geom_histogram(position=&quot;identity&quot;, alpha=0.5)+ geom_vline(data=meantwomonths, aes(xintercept=grp.mean, color=Month), linetype=&quot;dashed&quot;)+ labs(title=&quot;Ggplot2 histogram of Australian Jan and Jun temperatures&quot;,x=&quot;Temperature&quot;,y=&quot;Frequency&quot;)+ theme_classic()+ theme(plot.title = element_text(hjust = 0.5)) Note how i adjusted the title after i selected the theme, if i had done this before the theme defaults would have overwritten my command. Have you been getting an annoying error message about bin size and non-finate values? Me too!…Bin size defaults to 30 in ggplot2 and the non-finate values is referring to lots of NAs (no data) that we have in our dataset. In the code below i’ve selected a bin width of 5 and removed all the NAs with complete.cases and produced a faceted plot… # Remove all NAs data_complete_cases &lt;- squishdata[complete.cases(squishdata), ] # How many rows are left dim(data_complete_cases) ## [1] 1201812 2 # How many were there to start with dim(squishdata) ## [1] 3663048 2 # Plot faceted histogram ggplot(data_complete_cases, aes(x=value, na.rm=TRUE))+ geom_histogram(color=&quot;black&quot;, fill=&quot;white&quot;, binwidth = 5)+ labs(title=&quot;Ggplot2 faceted histogram of Australian temperatures&quot;, x=&quot;Temperature&quot;, y=&quot;Frequency&quot;)+ facet_grid(variable ~ .)+ theme(plot.title = element_text(hjust = 0.5)) Does this seem right to you? Well…yes. It shows that the distribution of temperature is higher (or warmer) in the Australian summer (Dec-Feb) than the rest of the year, which makes perfect sense. How about an interactive histogram using plotly… See if you can understand what is going on in the code below. Run each line seperately. library(plotly) # split the data for plotly based on month jan&lt;-subset(squishdata, variable==&quot;Jan&quot;, na.rm=TRUE) jun&lt;-subset(squishdata, variable==&quot;Jun&quot;, na.rm=TRUE) # give axis titles x &lt;- list (title = &quot;Temperature&quot;) y &lt;- list (title = &quot;Frequency&quot;) # set the bin width xbinsno&lt;-list(start=0, end=40, size = 2.5) # plot the histogram calling all the variables we just set ihist&lt;-plot_ly(alpha = 0.6) %&gt;% add_histogram(x = jan$value, xbins=xbinsno, name=&quot;January&quot;) %&gt;% add_histogram(x = jun$value, xbins=xbinsno, name=&quot;June&quot;) %&gt;% layout(barmode = &quot;overlay&quot;, xaxis=x, yaxis=y) ihist This format of code where you set lots of varaibles then call them within a plot, package or fuction is sometihng you should become more familiar with as it’s considerd good practice. If you were to go on and produce multiple plots using the same legends / aesthetics you only ahve to set them once. Ok so enough with the histograms…the point is to think about how to best display your data both effectively and efficiently. Let’s change the pace a bit and do a quickfire of other descrptive statistics you might want to use… library(dplyr) # mean per month meanofall &lt;- ddply(squishdata, &quot;variable&quot;, summarise, grp.mean=mean(value, na.rm=TRUE)) # print the top 1 head(meanofall, n=1) ## variable grp.mean ## 1 Jan 28.11321 # standard deviation per month sdofall &lt;- ddply(squishdata, &quot;variable&quot;, summarise, grp.sd=sd(value, na.rm=TRUE)) # maximum per month maxofall &lt;- ddply(squishdata, &quot;variable&quot;, summarise, grp.mx=max(value, na.rm=TRUE)) # minimum per month minofall &lt;- ddply(squishdata, &quot;variable&quot;, summarise, grp.min=min(value, na.rm=TRUE)) # Interquartlie range per month IQRofall &lt;- ddply(squishdata, &quot;variable&quot;, summarise, grp.IQR=IQR(value, na.rm=TRUE)) # perhaps you want to store multiple outputs in one list.. lotsofthem &lt;- ddply(squishdata, &quot;variable&quot;, summarise,grp.min=min(value,na.rm=TRUE), grp.mx=max(value, na.rm=TRUE)) # or you want to know the mean (or some other stat) for the whole year as opposed to each month... meanwholeyear=mean(squishdata$value, na.rm=TRUE) 2.5 Part 3 interpolation What if you had a selection of points over a spatial area but wanted to generate a complete raster. For this example, we will take our sample points (Australian cities) and estimate data between them using interpolation. If you look at our samples and AUcitytemp data the lat and lon is only in the former. We need to have this with our temperature data so let’s combine it using cbind samplestemp&lt;-cbind(AUcitytemp, samples) Now we need to tell R that our points are spatial points library(dplyr) spatialpt &lt;- SpatialPoints(select(samplestemp,lon,lat), proj4string = crs(worldclimtemp)) spatialpt &lt;- SpatialPointsDataFrame(spatialpt, samplestemp) You’ll notice that here i’ve used dplyr to select the longitude and latitude from my samplestemp data and i just nicked the CRS from our worldclimtemp. In generally it’s good practice to avoid using static or hard coding references, by that i mean if we added another coloumn to our samplestemp data (or manipulated somehow) then using this… spatialpt &lt;- SpatialPoints(samplestemp[13:14], proj4string = CRS(&quot;+proj=longlat +datum=WGS84+no_defs+ellps=WGS84 +towgs84=0,0,0&quot;)) Would give us a headache as coloumns 13 and 14 might no longer be longitude and latitude. Right…plot the Australian geometry outline then add our spatial data points ontop… plot(Ausoutline$geom) plot(spatialpt, col=&quot;red&quot;, add=TRUE) Let’s interpolate using Inverse Distance Weighting, or IDW as it’s more commonly known. IDW is a deterministic method for multivaraite interpolation that estaimtes values for a surface using a weighted average of the provided data. The values closer to the point being predicted have more weight than those further away. The rate at which distance from the provided point imapcts the predcted point is controlled by the power of p. If p=0 then there is no decrease with distance. For more infomation see: https://pro.arcgis.com/en/pro-app/help/analysis/geostatistical-analyst/how-inverse-distance-weighted-interpolation-works.htm spatialpt = st_as_sf(spatialpt) spatialpt &lt;- st_transform(spatialpt, 4283) spatialpt&lt;-as(spatialpt, &#39;Spatial&#39;) library(gstat) # Create an empty grid where cellsize is the spatial resolution # Cellsize will overwrite the number of pixels we specified (n) emptygrd &lt;- as.data.frame(spsample(spatialpt, n=1000, type=&quot;regular&quot;, cellsize=0.2)) names(emptygrd) &lt;- c(&quot;X&quot;, &quot;Y&quot;) coordinates(emptygrd) &lt;- c(&quot;X&quot;, &quot;Y&quot;) gridded(emptygrd) &lt;- TRUE # Create SpatialPixel object fullgrid(emptygrd) &lt;- TRUE # Create SpatialGrid object # Add the projection to the grid proj4string(emptygrd) &lt;- proj4string(spatialpt) # Interpolate the grid cells using a power value of 2 interpolate &lt;- gstat::idw(Jan ~ 1, spatialpt, newdata=emptygrd, idp=2.0) ## [inverse distance weighted interpolation] # Convert output to raster object ras &lt;- raster(interpolate) # Clip the raster to Australia outline rasmask &lt;- mask(ras, Ausoutline) # Plot the raster rasmask ## class : RasterLayer ## dimensions : 279, 189, 52731 (nrow, ncol, ncell) ## resolution : 0.2, 0.2 (x, y) ## extent : 115.6375, 153.4375, -37.93308, 17.86692 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs ## source : memory ## names : var1.pred ## values : 19.66823, 28.28939 (min, max) I’ve been a bit lazy here, if you recall from the previous practical session there are different ways to reproject data based if you have an SP or SF object. SP objects require you to specify the entire CRS string, so i just convered it to SF, used the ESPG code and converted it back to SP. The main reason for doing this is that i made a grid to store my interpolation and having a remote sensing background i wanted to specify the pixel size. The equivalent function if SF won’t let you specify pixel size or there is no easy and straightforward way to do it (at least to my knowledge). There are also many more methods for interpolation, check out: https://mgimond.github.io/Spatial/interpolation-in-r.html 2.6 Auto data download In this practical I’ve shown you how to source the data online, download it and load it into R. However for both WorldClim and GADM we can do this straight from R using the getData function….i’m sorry for making you do it the long way, but it’s good to do things manually to see how they work. WARNING, this may take some time. I’ve changed the resolution to 10 degrees, but I’d advise not running this in the practical session. #WorldClim data has a scale factor of 10 when using getData! tmean_auto &lt;- getData(&quot;worldclim&quot;, res=10, var=&quot;tmean&quot;) tmean_auto &lt;- tmean_auto/10 Now for GADM Aus_auto &lt;- getData(&#39;GADM&#39;, country=&quot;AUS&quot;, level=0) Much more convenient right? 2.7 Advanced analysis Are you already comptent with raster analysis and R, then have a go at completing this task in the practical session. Within the practical we’ve loaded one and created one raster layer. Undertake some comparative analysis to detemrine spatial (and temporal if appropraite) differences between the rasters here and any others you may wish to create (e.g. from other interpolation methods). Try to identify where the varaitions are and explain why they are occuring. You could assume that one raster is the ‘gold standard’ meaning it’s beleived to be fully correct and compare others to it. … Or you could go further than this and obtain weather station temperature data (or any other variable) for multiple sites, interpolate based on 50% of the sites and use the remaining sites to assess the accuracy of your selected method / the WorldClim data. Free weather station data can be found here: https://rp5.ru/Weather_in_the_world Have a go and discuss with your fellow students / members of the teaching team during the practical sessions or on slack. "],
["geocomputation-and-making-cool-maps.html", "Chapter 3 Geocomputation and making cool maps 3.1 Learning outcomes 3.2 Geocomputation", " Chapter 3 Geocomputation and making cool maps 3.1 Learning outcomes By the end of this practical you should be able to: t 3.2 Geocomputation 3.2.1 General ggplot2 maps 3.2.2 Bivaraite chloropleth maps 3.2.3 Rayshader 3.2.4 Shiny "],
["an-introduction-to-analysing-spatial-patterns.html", "Chapter 4 An Introduction to Analysing Spatial Patterns 4.1 Point Pattern Analysis 4.2 Analysing Spatial Autocorrelation with Moran’s I, LISA and friends", " Chapter 4 An Introduction to Analysing Spatial Patterns In this practical you will learn how to begin to analyse patterns in spatial data. Using data you are already familiar with, in the first part of the practical, you will explore some techniques for analysing patterns of point data in R. Then, in the second part of the practial, you will explore spatial autocorrelation using ArcGIS. 4.1 Point Pattern Analysis In this analysis we will analyse the patterns of Blue Plaques you downloaded from http://openplaques.org/ in the Week 5 practial. Normally we could download the XML directly from the Web using a package like xml, but the XML feeds from OpenPlaques are a little flaky, so we’ll read in the shapefile for Blue Plaques for London we created in week 5. The question we want to answer is: “For any given London Borough, are the Blue Plaques within that borough distributed randomly or do they exhibit some kind of dispersed or clustered pattern?” To answer this question, we will make use of some of the Point Pattern Analysis functions found in the spatstat package. #first library a few packages that we will use during the practical #note you may need to install them first... library(spatstat) library(sp) library(rgeos) library(maptools) library(GISTools) library(tmap) library(sf) library(geojsonio) library(tmaptools) 4.1.1 Setting up Your Data Now, assuming that you’ve got a copy of your London Boroughs shapefile (from week 1) in your new week 6 folder, along with a shapefile of your Blue Plaques; read in the data… ##First, get the London Borough Boundaries EW &lt;- geojson_read(&quot;http://geoportal.statistics.gov.uk/datasets/8edafbe3276d4b56aec60991cbddda50_2.geojson&quot;, what = &quot;sp&quot;) Pull out london using grep and the regex wildcard for’start of the string’ (^) to to look for the bit of the district code that relates to London (E09) from the ‘lad15cd’ column in the data slot of our spatial polygons dataframe BoroughMap &lt;- EW[grep(&quot;^E09&quot;,EW@data$lad15cd),] #plot it using the base plot function qtm(BoroughMap) summary(BoroughMap) ## Object of class SpatialPolygonsDataFrame ## Coordinates: ## min max ## x -0.510277 0.3340243 ## y 51.286759 51.6918756 ## Is projected: FALSE ## proj4string : ## [+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0] ## Data attributes: ## lad15cd lad15nm lad15nmw objectid ## E09000001: 1 Barking and Dagenham: 1 :33 Min. :294 ## E09000002: 1 Barnet : 1 Abertawe : 0 1st Qu.:302 ## E09000003: 1 Bexley : 1 Blaenau Gwent: 0 Median :310 ## E09000004: 1 Brent : 1 Bro Morgannwg: 0 Mean :310 ## E09000005: 1 Bromley : 1 Caerdydd : 0 3rd Qu.:318 ## E09000006: 1 Camden : 1 Caerffili : 0 Max. :326 ## (Other) :27 (Other) :27 (Other) : 0 ## st_lengthshape st_areashape ## Min. : 8929 Min. : 2897649 ## 1st Qu.:28384 1st Qu.: 26797942 ## Median :37664 Median : 37628571 ## Mean :39255 Mean : 47682317 ## 3rd Qu.:46679 3rd Qu.: 56413925 ## Max. :74641 Max. :150125298 ## BNG = &quot;+init=epsg:27700&quot; BoroughMapBNG &lt;- spTransform(BoroughMap,BNG) ##Now get the location of all Blue Plaques in the City BluePlaques &lt;- geojson_read(&quot;https://s3.eu-west-2.amazonaws.com/openplaques/open-plaques-london-2018-04-08.geojson&quot;, what = &quot;sp&quot;) summary(BluePlaques) ## Object of class SpatialPointsDataFrame ## Coordinates: ## min max ## coords.x1 -0.477 0.21903 ## coords.x2 0.000 51.67830 ## Is projected: FALSE ## proj4string : ## [+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0] ## Number of points: 2812 ## Data attributes: ## id ## Min. : 1.0 ## 1st Qu.: 711.8 ## Median : 6089.0 ## Mean :10622.0 ## 3rd Qu.:10358.2 ## Max. :49190.0 ## ## inscription ## Frank Matcham (1854-1920) theatre architect designed this theatre : 3 ## Charlie Chester MBE : 2 ## Grimâ\\200\\231s Dyke : 2 ## Lillie Langtry 1852-1929 actress lived here : 2 ## &#39;Canons&#39; gate pillars\\r\\nEntrance gate piers to &#39;Canons&#39; from Old Turnpike Road\\r\\nBuilt in 1712 for James Brydges 1673-1744, 1st Duke of Chandos. House demolished 1740 and existing buildings constructed from salvaged materials. Piers refurbished 1998.: 1 ## &#39;Father&#39; Henry Willis 1821-1901 organ builder lived here : 1 ## (Other) :2801 #now set up an EPSG string to help set the projection BNG = &quot;+init=epsg:27700&quot; WGS = &quot;+init=epsg:4326&quot; BluePlaquesBNG &lt;- spTransform(BluePlaques, BNG) summary(BluePlaquesBNG) ## Object of class SpatialPointsDataFrame ## Coordinates: ## min max ## coords.x1 505575.2 622211.7 ## coords.x2 -5527598.3 199509.2 ## Is projected: TRUE ## proj4string : ## [+init=epsg:27700 +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ## +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs ## +ellps=airy ## +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894] ## Number of points: 2812 ## Data attributes: ## id ## Min. : 1.0 ## 1st Qu.: 711.8 ## Median : 6089.0 ## Mean :10622.0 ## 3rd Qu.:10358.2 ## Max. :49190.0 ## ## inscription ## Frank Matcham (1854-1920) theatre architect designed this theatre : 3 ## Charlie Chester MBE : 2 ## Grimâ\\200\\231s Dyke : 2 ## Lillie Langtry 1852-1929 actress lived here : 2 ## &#39;Canons&#39; gate pillars\\r\\nEntrance gate piers to &#39;Canons&#39; from Old Turnpike Road\\r\\nBuilt in 1712 for James Brydges 1673-1744, 1st Duke of Chandos. House demolished 1740 and existing buildings constructed from salvaged materials. Piers refurbished 1998.: 1 ## &#39;Father&#39; Henry Willis 1821-1901 organ builder lived here : 1 ## (Other) :2801 #plot the blue plaques in the city tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(BoroughMapBNG) + tm_polygons(col = NA, alpha = 0.5) + tm_shape(BluePlaquesBNG) + tm_dots(col = &quot;blue&quot;) Now, you might have noticed that there is at least one Blue Plaque that falls outside of the Borough boundaries. Errant plaques will cause problems with our analysis, so we need to clip the plaques to the boundaries…First we’ll remove any Plaques with the same grid reference as this will cause problems later on in the analysis.. #remove duplicates BluePlaquesBNG &lt;- remove.duplicates(BluePlaquesBNG) Now just select the points inside London - thanks to Robin Lovelace for posting how to do this one, very useful! BluePlaquesSub &lt;- BluePlaquesBNG[BoroughMapBNG,] #check to see that they&#39;ve been removed tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(BoroughMapBNG) + tm_polygons(col = NA, alpha = 0.5) + tm_shape(BluePlaquesSub) + tm_dots(col = &quot;blue&quot;) From this point, we could try and carry out our analysis on the whole of London, but you might be waiting until next week for Ripley’s K to be calculated for this many points. Therefore to speed things up and to enable us to compare areas within London, we will select some individual boroughs. First we need to subset our SpatialPolygonsDataFrame to pull out a borough we are interested in. I’m going to choose Harrow as I know there are few enough points for the analysis to definitely work. If you wish, feel free to choose another borough in London and run the same analysis, but beware that if it happens that there are a lot of blue plaques in your borough, the analysis could fall over!! #extract the borough Borough &lt;- BoroughMapBNG[BoroughMapBNG@data$lad15nm==&quot;Harrow&quot;,] #or as an sf object: BoroughMapBNGSF &lt;- st_as_sf(BoroughMapBNG) BoroughSF &lt;- BoroughMapBNGSF[BoroughMapBNGSF$lad15nm==&quot;Harrow&quot;,] #Check to see that the correct borough has been pulled out tm_shape(Borough) + tm_polygons(col = NA, alpha = 0.5) Next we need to clip our Blue Plaques so that we have a subset of just those that fall within the borough or interest #clip the data to our single borough BluePlaquesSub &lt;- BluePlaquesBNG[Borough,] #check that it&#39;s worked tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(Borough) + tm_polygons(col = NA, alpha = 0.5) + tm_shape(BluePlaquesSub) + tm_dots(col = &quot;blue&quot;) We now have all of our data set up so that we can start the analysis using spatstat. The first thing we need to do is create an observation window for spatstat to carry out its analysis within — we’ll set this to the extent of the Harrow boundary ##now set a window as the borough boundary window &lt;- as.owin(Borough) plot(window) spatstat has its own set of spatial objects that it works with (one of the delights of R is that different packages are written by different people and many have developed their own data types) - it does not work directly with the SpatialPolygonsDataFrames, SpatialPointsDataFrames or sf objects that we are used to. For point pattern analysis, we need to create a point pattern (ppp) object. #create a ppp object BluePlaquesSub.ppp &lt;- ppp(x=BluePlaquesSub@coords[,1],y=BluePlaquesSub@coords[,2],window=window) Try to understand what the different elements in command above is doing. If you are unsure, you can run elements of the code, for example: BluePlaquesSub@coords[,1] ## [1] 514971.1 512466.7 514966.0 517339.4 512215.1 515694.1 512269.5 ## [8] 511792.6 515333.7 518598.3 515370.2 512335.7 511539.4 513371.5 ## [15] 516746.3 515210.7 515093.2 515561.8 514805.8 513053.6 515166.2 ## [22] 513750.4 512508.2 516451.0 514022.4 518187.5 516725.5 513392.3 ## [29] 513008.4 514177.1 515300.0 514183.4 518560.0 512639.2 515491.4 ## [36] 514789.8 519099.9 512346.3 512343.2 Have a look at the new ppp object plot(BluePlaquesSub.ppp,pch=16,cex=0.5, main=&quot;Blue Plaques Harrow&quot;) 4.1.1.1 Summarising your point data - a little aside on Kernel Density Estimation We will explore what Kernel Density Estimation (KDE) is in a couple of week’s, but here we are going to jump the gun a little bit. One way to summarise your point data is to plot the density of your points under a window called a ‘Kernel’. The size and shape of the Kernel affects the density pattern produced (more of this next week), but it is very easy to produce a KDE map from a ppp object using the density function. plot(density(BluePlaquesSub.ppp, sigma = 500)) The sigma value sets the diameter of the Kernel (in the units your map is in - in this case, as we are in British National Grid the units are in metres). Try experimenting with different values of sigma to see how that affects the density estimate. plot(density(BluePlaquesSub.ppp, sigma = 1000)) 4.1.2 Quadrat Analysis So as you saw in the lecture, we are interesting in knowing whether the distribution of points in our study area differs from ‘complete spatial randomness’ - CSR. The most basic test of CSR is a quadrat analysis. We can carry out a simple quadrat analysis on our data using the quadrat count function in spatstat. Note, I wouldn’t recommend doing a quadrat analysis in any real piece of analysis you conduct, but it is useful for starting to understand the Poisson distribution… #First plot the points plot(BluePlaquesSub.ppp,pch=16,cex=0.5, main=&quot;Blue Plaques in Harrow&quot;) #now count the points in that fall in a 6 x 6 grid overlaid across the window plot(quadratcount(BluePlaquesSub.ppp, nx = 6, ny = 6),add=T,col=&quot;red&quot;) In our case here, want to know whether or not there is any kind of spatial patterning associated with the Blue Plaques in areas of London. If you recall from the lecture, this means comparing our observed distribution of points with a statistically likely (Complete Spatial Random) distibution, based on the Poisson distribution. Using the same quadratcount function again (for the same sized grid) we can save the results into a table: #run the quadrat count Qcount&lt;-data.frame(quadratcount(BluePlaquesSub.ppp, nx = 6, ny = 6)) #put the results into a data frame QCountTable &lt;- data.frame(table(Qcount$Freq, exclude=NULL)) #view the data frame QCountTable ## Var1 Freq ## 1 0 12 ## 2 1 8 ## 3 2 4 ## 4 3 1 ## 5 4 2 ## 6 5 1 ## 7 7 1 #we don&#39;t need the last row, so remove it QCountTable &lt;- QCountTable[-nrow(QCountTable),] Check the data type in the first column - if it is factor, we will need to convert it to numeric class(QCountTable[,1]) ## [1] &quot;factor&quot; #oops, looks like it&#39;s a factor, so we need to convert it to numeric vect&lt;- as.numeric(levels(QCountTable[,1])) vect &lt;- vect[1:6] QCountTable[,1] &lt;- vect OK, so we now have a frequency table - next we need to calculate our expected values. The formula for calculating expected probabilities based on the Poisson distribution is: \\[ Pr\\left(X=k\\right)=\\frac{\\lambda^{k}e^{-\\lambda}}{k!} \\] #calculate the total blue plaques (Var * Freq) QCountTable$total &lt;- QCountTable[,1]*QCountTable[,2] #calculate mean sums &lt;- colSums(QCountTable[,-1]) sums ## Freq total ## 28 32 #and now calculate our mean Poisson parameter (lambda) lambda &lt;- sums[2]/sums[1] Calculate expected using the Poisson formula from above — k is the number of blue plaques counted in a square and is found in the first column of our table… QCountTable$Pr &lt;- ((lambda^QCountTable[,1])*exp(-lambda))/factorial(QCountTable[,1]) #now calculate the expected counts and save them to the table QCountTable$Expected &lt;- round(QCountTable$Pr * sums[1],0) QCountTable ## Var1 Freq total Pr Expected ## 1 0 12 0 0.318906557 9 ## 2 1 8 8 0.364464637 10 ## 3 2 4 8 0.208265507 6 ## 4 3 1 3 0.079339241 2 ## 5 4 2 8 0.022668354 1 ## 6 5 1 5 0.005181338 0 #Compare the frequency distributions of the observed and expected point patterns plot(c(1,5),c(0,14), type=&quot;n&quot;, xlab=&quot;Number of Blue Plaques (Red=Observed, Blue=Expected)&quot;, ylab=&quot;Frequency of Occurances&quot;) points(QCountTable$Freq, col=&quot;Red&quot;, type=&quot;o&quot;, lwd=3) points(QCountTable$Expected, col=&quot;Blue&quot;, type=&quot;o&quot;, lwd=3) Comparing the observed and expected frequencies for our quadrat counts, we can observe that they both have higher frequency counts at the lower end - something reminiscent of a Poisson distribution. This could indicate that for this particular set of quadrats, our pattern is close to Complete Spatial Randomness (i.e. no clustering or dispersal of points). But how do we confirm this? To check for sure, we can use the quadrat.test function, built into spatstat. This uses a Chi Squared test to compare the observed and expected frequencies for each quadrat (rather than for quadrat bins, as we have just computed above). If the p-value of our Chi-Squared test is &gt; 0.05, then we can reject a null hyphothesis that says “there is no complete spatial randomness in our data” (we will learn more about what a null-hypothesis is in a couple of weeks, but for the time being, just think about it as the opposite of a hypothesis that says our data exhibit complete spatial randomness). What we need to look for is a value for p &gt; 0.05. If our p-value is &gt; 0.05 then this indicates that we have CSR and there is no pattern in our points. If it is &lt; 0.05, this indicates that we do have clustering in our points. teststats &lt;- quadrat.test(BluePlaquesSub.ppp, nx = 6, ny = 6) teststats ## ## Chi-squared test of CSR using quadrat counts ## Pearson X2 statistic ## ## data: BluePlaquesSub.ppp ## X2 = 37.959, df = 28, p-value = 0.1984 ## alternative hypothesis: two.sided ## ## Quadrats: 29 tiles (irregular windows) plot(BluePlaquesSub.ppp,pch=16,cex=0.5, main=&quot;Blue Plaques in Harrow&quot;) plot(teststats, add=T, col = &quot;red&quot;) So we can see that the indications are there is no spatial patterning for Blue Plaques in Harrow - at least for this particular grid. Note the warning message - some of the observed counts are very small (0) and this may affect the accuracy of the quadrat test. Recall that the Poisson distribution only describes observed occurrances that are counted in integers - where our occurances = 0 (i.e. not observed), this can be an issue. We also know that there are various other problems that might affect our quadrat analysis, such as the modifiable areal unit problem. In the new plot, we can see three figures for each quadrat. The top-left figure is the observed count of points; the top-right is the Poisson expected number of points; the bottom value is the Pearson residual value, or (Observed - Expected) / Sqrt(Expected). 4.1.2.1 Try experimenting… Try running a quadrat analysis for different grid arrangements (2 x 2, 3 x 3, 10 x 10 etc.) - how does this affect your results? 4.1.3 Ripley’s K One way of getting around the limitations of quadrat analysis is to compare the observed distribution of points with the Poisson random model for a whole range of different distance radii. This is what Ripley’s K function computes. We can conduct a Ripley’s K test on our data very simply with the spatstat package using the kest function. K &lt;- Kest(BluePlaquesSub.ppp, correction=&quot;border&quot;) plot(K) The plot for K has a number of elements that are worth explaining. First, the Kpois(r) line in Red is the theoretical value of K for each distance window (r) under a Poisson assumption of Complete Spatial Randomness. The Black line is the estimated values of K accounting for the effects of the edge of the study area. Where the value of K falls above the line, the data appear to be clustered at that distance. Where the value of K is below the line, the data are dispersed. From the graph, we can see that up until distances of around 1300 metres, Blue Plaques appear to be clustered in Harrow, however, at around 1500 m, the distribution appears random and then dispersed between about 1600 and 2100 metres. 4.1.3.1 Alternatives to Ripley’s K There are a number of alternative measures of spatial clustering which can be computed in spatstat such as the G and the L functions - I won’t go into them now, but if you are interested, you should delve into the following references: Bivand, R. S., Pebesma, E. J., &amp; Gómez-Rubio, V. (2008). “Applied spatial data analysis with R.” New York: Springer. Brundson, C., Comber, L., (2015) “An Introduction to R for Spatial Analysis &amp; Mapping”. Sage. https://research.csiro.au/software/wp-content/uploads/sites/6/2015/02/Rspatialcourse_CMIS_PDF-Standard.pdf 4.1.4 Density-based spatial clustering of applications with noise: DBSCAN Quadrat and Ripley’s K analysis are useful exploratory techniques for telling us if we have spatial clusters present in our point data, but they are not able to tell us WHERE in our area of interest the clusters are occurring. To discover this we need to use alternative techniques. One popular technique for discovering clusters in space (be this physical space or variable space) is DBSCAN. For the complete overview of the DBSCAN algorithm, read the original paper by Ester et al. (1996) - http://www.aaai.org/Papers/KDD/1996/KDD96-037.pdf or consult the wikipedia page - https://en.wikipedia.org/wiki/DBSCAN library(raster) library(fpc) library(plyr) library(OpenStreetMap) We will now carry out a DBSCAN analysis of blue plaques in my borough to see if there are any clusters present. #first check the coordinate reference system of the Harrow spatial polygon: crs(Borough) ## CRS arguments: ## +init=epsg:27700 +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ## +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs ## +ellps=airy ## +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894 DBSCAN requires you to input two parameters: 1. Epsilon - this is the radius within which the algorithm with search for clusters 2. MinPts - this is the minimum number of points that should be considered a cluster Based on the results of the Ripley’s K analysis earlier, we can see that we are getting clustering up to a radius of around 1200m, with the largest bulge in the graph at around 700m. Therefore, 700m is probably a good place to start and we will begin by searching for clusters of at least 4 points… #first extract the points from the spatial points data frame BluePlaquesSubPoints &lt;- data.frame(BluePlaquesSub@coords[,1:2]) #now run the dbscan analysis db &lt;- fpc::dbscan(BluePlaquesSubPoints, eps = 700, MinPts = 4) #now plot the results plot(db, BluePlaquesSubPoints, main = &quot;DBSCAN Output&quot;, frame = F) plot(Borough, add=T) #dbscan::kNNdistplot(BluePlaquesSubPoints, k = 4) So the DBSCAN analysis shows that for these values of eps and MinPts there are three clusters in the area I am analysing. Try varying eps and MinPts to see what difference it makes to the output. No of course the plot above is a little basic and doesn’t look very aesthetically pleasing. As this is R and R is brilliant, we can always produce a much nicer plot by extracting the useful information from the DBSCAN output and use ggplot2 to produce a much cooler map… #our new db object contains lots of info including the cluster each set of point #coordinates belongs to, whether the point is a seed point or a border point etc. #We can get a summary by just calling the object library(ggplot2) Our new db object contains lots of info including the cluster each set of point coordinates belongs to, whether the point is a seed point or a border point etc. We can get a summary by just calling the object db ## dbscan Pts=39 MinPts=4 eps=700 ## 0 1 2 3 4 ## border 15 0 1 3 4 ## seed 0 8 6 1 1 ## total 15 8 7 4 5 If you open up the object in the environment window in RStudio, you will also see the various slots in the object, including cluster db$cluster ## [1] 2 1 2 0 1 0 1 0 2 3 2 1 0 4 0 2 0 0 0 4 2 4 1 0 4 3 0 4 0 0 2 0 3 1 0 ## [36] 0 3 1 1 We can now add this cluster membership info back into our dataframe BluePlaquesSubPoints$cluster &lt;- db$cluster Next we are going to create some convex hull polygons to wrap around the points in our clusters. Use the ddply function in the plyr package to get the convex hull coordinates from the cluster groups in our dataframe chulls &lt;- ddply(BluePlaquesSubPoints, .(cluster), function(df) df[chull(df$coords.x1, df$coords.x2), ]) As 0 isn’t actually a cluster (it’s all points that aren’t in a cluster) drop it from the dataframe chulls &lt;- subset(chulls, cluster&gt;=1) Now create a ggplot2 object from our data dbplot &lt;- ggplot(data=BluePlaquesSubPoints, aes(coords.x1,coords.x2, colour=cluster, fill=cluster)) #add the points in dbplot &lt;- dbplot + geom_point() #now the convex hulls dbplot &lt;- dbplot + geom_polygon(data = chulls, aes(coords.x1,coords.x2, group=cluster), alpha = 0.5) #now plot, setting the coordinates to scale correctly and as a black and white plot #(just for the hell of it)... dbplot + theme_bw() + coord_equal() Now we are getting there, but wouldn’t it be better to add a basemap?! ###add a basemap ##First get the bbox in lat long for Harrow latlong &lt;- &quot;+init=epsg:4326&quot; BoroughWGS &lt;-spTransform(Borough, CRS(latlong)) BoroughWGS@bbox ## min max ## x -0.4040502 -0.2671315 ## y 51.5530624 51.6405356 Now convert the basemap to British National Grid basemap&lt;-openmap(c(51.5530613,-0.4040719),c(51.6405318,-0.2671556), zoom=NULL,&quot;stamen-toner&quot;) #convert the basemap to British National Grid - remember we created the BNG object right at the beginning of the practical - it&#39;s an epsg string... basemap_bng&lt;-openproj(basemap, projection=BNG) Now we can plot our fancy map with the clusters on… autoplot(basemap_bng) + geom_point(data=BluePlaquesSubPoints, aes(coords.x1,coords.x2, colour=cluster, fill=cluster)) + geom_polygon(data = chulls, aes(coords.x1,coords.x2, group=cluster, fill=cluster), alpha = 0.5) This is end end of the point pattern analysis section of the practical. You have been introduced to the basics of Point Pattern Analysis examining the distribution of Blue Plaques in a London Borough. At this point, you may wish to try running similar analyses on different boroughs (or indeed the whole city) and playing with some of the outputs - although you will find that Ripley’s K will fall over very quickly if you try to run the analysis on that many points) This how you might make use of these techniques in another context or with different point data… 4.2 Analysing Spatial Autocorrelation with Moran’s I, LISA and friends Now, at this point you have a choice and at bit like in those Fighting Fantasy (https://en.wikipedia.org/wiki/Fighting_Fantasy) books that I used to read as a kid, you can select either option 1 (which may lead to firey death by dragon) or option 2 (which could lead to a pot of gold)… Option 1. If you’ve had enough of coding and you think you might like to do your coursework in ArcGIS and have a bit more practice with model builder, then you should go over to Moodle and carry out the exercise on the ‘Practical 6 - Part 2’ handout that is on there. This will show you how to analyse spatial autocorrelation in ArcGIS and will give you more practice will model builder. Option 2. If you are a total bad-ass and want to continue with R, then briliant!! Woo hoo!! You can keep following the instuctions below. Have the Arc lot gone? OK great, here’s some more lovely R… In this section we are going to explore patterns of spatially referenced continuous observations using various measures of spatial autocorrelation. Check out the various references in the reading list for more information about these methods. There are also useful links in the helpfile of the spdep package which we will be using here. Before we get any further, let’s get some ward boundaries read in to R - download LondonWardData from Moodle, unzip it and then read it in. #it’s probably projected correctly, but in case it isn’t give it a projection #using the CRS() function in the raster package library(rgdal) ## rgdal: version: 1.4-4, (SVN revision 833) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20 ## Path to GDAL shared files: C:/Users/ucfnmac/Documents/R/win-library/3.6/rgdal/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493] ## Path to PROJ.4 shared files: C:/Users/ucfnmac/Documents/R/win-library/3.6/rgdal/proj ## Linking to sp version: 1.3-1 #read the ward data in LondonWards &lt;- readOGR(&quot;prac6_data/LondonWards.shp&quot;) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;N:\\Documents\\Teaching\\CASA0005practicals\\CASA0005repo\\prac6_data\\LondonWards.shp&quot;, layer: &quot;LondonWards&quot; ## with 625 features ## It has 77 fields Tt’s probably projected correctly, but in case it isn’t give it a projection using the CRS() function in the raster package proj4string(LondonWards) &lt;- CRS(&quot;+init=epsg:27700&quot;) ## Warning in `proj4string&lt;-`(`*tmp*`, value = new(&quot;CRS&quot;, projargs = &quot;+init=epsg:27700 +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs +ellps=airy +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894&quot;)): A new CRS was assigned to an object with an existing CRS: ## +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs +ellps=airy +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894 ## without reprojecting. ## For reprojection, use function spTransform #have a look to check that everything looks OK.. tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tm_shape(LondonWards) + tm_polygons(col = NA, alpha = 0.5) + tm_shape(BluePlaques) + tm_dots(col = &quot;blue&quot;) Ah yes, we might need to lose the blue plaques that fall outside of London summary(BluePlaquesBNG) ## Object of class SpatialPointsDataFrame ## Coordinates: ## min max ## coords.x1 505575.2 622211.7 ## coords.x2 -5527598.3 199509.2 ## Is projected: TRUE ## proj4string : ## [+init=epsg:27700 +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ## +x_0=400000 +y_0=-100000 +datum=OSGB36 +units=m +no_defs ## +ellps=airy ## +towgs84=446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894] ## Number of points: 2711 ## Data attributes: ## id ## Min. : 1.0 ## 1st Qu.: 698.5 ## Median : 6154.0 ## Mean :10724.9 ## 3rd Qu.:10397.0 ## Max. :49190.0 ## ## inscription ## Frank Matcham (1854-1920) theatre architect designed this theatre : 3 ## Grimâ\\200\\231s Dyke : 2 ## Lillie Langtry 1852-1929 actress lived here : 2 ## &#39;Canons&#39; gate pillars\\r\\nEntrance gate piers to &#39;Canons&#39; from Old Turnpike Road\\r\\nBuilt in 1712 for James Brydges 1673-1744, 1st Duke of Chandos. House demolished 1740 and existing buildings constructed from salvaged materials. Piers refurbished 1998.: 1 ## &#39;Father&#39; Henry Willis 1821-1901 organ builder lived here : 1 ## J. H. Greathead Chief Engineer City and South London Railway. Inventor of the Travelling Shield that made possible the cutting of the tunnels of London&#39;s deep level tube system : 1 ## (Other) :2701 BluePlaquesSub &lt;- BluePlaquesBNG[LondonWards,] tm_shape(LondonWards) + tm_polygons(col = NA, alpha = 0.5) + tm_shape(BluePlaquesSub) + tm_dots(col = &quot;blue&quot;) The measures of spatial autocorrelation that we will be using require continuous observations (counts of blue plaques, average GCSE scores, average incomes etc.) to be spatially referenced (i.e. attached to a spatial unit like a ward or a borough). The file you have already has the various obervations associated with the London Ward data file already attached to it, but let’s continue with our blue plaques example for now. To create a continuous observation from the blue plaques data we need to count all of the blue plaques that fall within each Ward in the City. Luckily, we can do this using the poly.counts function in Chris Brunsdon’s excellent gistools package… (we could also use the over() function in the sp package if we wanted) res &lt;- poly.counts(BluePlaquesSub, LondonWards) #and add this as a column in our spatialPolygonsDataframe LondonWards@data$BluePlaqueCount&lt;-res #as the wards are of different sizes, perhaps best that we calculate a density LondonWards@data$BlueDensity &lt;- LondonWards$BluePlaqueCount/poly.areas(LondonWards) #let&#39;s just check the data to see if the calculations have worked LondonWards@data How about a quick choropleth map to see how we are getting on… tm_shape(LondonWards) + tm_polygons(&quot;BlueDensity&quot;, style=&quot;jenks&quot;, palette=&quot;PuOr&quot;, midpoint=NA, title=&quot;Blue Plaque Density&quot;) So, from the map, it looks as though we might have some clustering of blue plaques in the centre of London so let’s check this with Moran’s I and some other statistics. Before being able to calculate Moran’s I and any similar statistics, we need to first define a \\(W_{ij}\\) spatial weights matrix library(spdep) First calculate the centroids of all Wards in London #First calculate the centroids of all Wards in London coordsW &lt;- coordinates(LondonWards) plot(coordsW) Now we need to generate a spatial weights matrix (remember from the lecture). We’ll start with a simple binary matrix of queen’s case neighbours #create a neighbours list LWard_nb &lt;- poly2nb(LondonWards, queen=T) #plot them plot(LWard_nb, coordinates(coordsW), col=&quot;red&quot;) #add a map underneath plot(LondonWards, add=T) #create a spatial weights object from these weights Lward.lw &lt;- nb2listw(LWard_nb, style=&quot;C&quot;) head(Lward.lw$neighbours) ## [[1]] ## [1] 6 7 10 462 468 482 ## ## [[2]] ## [1] 5 8 9 11 12 13 16 ## ## [[3]] ## [1] 10 11 12 15 480 483 ## ## [[4]] ## [1] 17 281 291 470 473 481 ## ## [[5]] ## [1] 2 9 16 281 283 290 ## ## [[6]] ## [1] 1 7 8 10 11 14 Now we have defined our \\(W_{ij}\\) matrix, we can calculate the Moran’s I and other associated statistics Moran’s I test tells us whether we have clustered values (close to 1) or dispersed values (close to -1), we will calculate for the densities rather than raw values I_LWard_Global_Density &lt;- moran.test(LondonWards@data$BlueDensity, Lward.lw) I_LWard_Global_Density ## ## Moran I test under randomisation ## ## data: LondonWards@data$BlueDensity ## weights: Lward.lw ## ## Moran I statistic standard deviate = 30.211, p-value &lt; 2.2e-16 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.6726785503 -0.0016025641 0.0004981274 Geary’s C as well..? This tells us whether similar values or dissimilar values are clusering C_LWard_Global_Density &lt;- geary.test(LondonWards@data$BlueDensity, Lward.lw) C_LWard_Global_Density ## ## Geary C test under randomisation ## ## data: LondonWards@data$BlueDensity ## weights: Lward.lw ## ## Geary C statistic standard deviate = 8.3637, p-value &lt; 2.2e-16 ## alternative hypothesis: Expectation greater than statistic ## sample estimates: ## Geary C statistic Expectation Variance ## 0.403108506 1.000000000 0.005093209 Getis Ord General G…? This tells us whether high or low values are clustering. If G &gt; Expected = High values clustering; if G &lt; expected = low values clustering G_LWard_Global_Density &lt;- globalG.test(LondonWards@data$BlueDensity, Lward.lw) G_LWard_Global_Density ## ## Getis-Ord global G statistic ## ## data: LondonWards@data$BlueDensity ## weights: Lward.lw ## ## standard deviate = 29.488, p-value &lt; 2.2e-16 ## alternative hypothesis: greater ## sample estimates: ## Global G statistic Expectation Variance ## 1.123988e-02 1.602564e-03 1.068124e-07 So the global statistics are indicating that we have spatial autocorrelation of Blue Plaques in London: The Moran’s I statistic = 0.51 (remember 1 = clustered, 0 = no pattern, -1 = dispersed) which shows that we have some distinctive clustering The Geary’s C statistic = 0.41 (remember Geary’s C falls between 0 and 2; 1 means no spatial autocorrelation, &lt;1 - positive spatial autocorrelation or similar values clustering, &gt;1 - negative spatial autocorreation or dissimilar values clustering) which shows that similar values are clustering The General G statistic = G &gt; expected, so high values are tending to cluster. We can now also calculate local versions of the Moran’s I statistic (for each Ward) and a Getis Ord \\(G_{i}^{*}\\) statistic to see where we have hot-spots… #use the localmoran function to generate I for each ward in the city I_LWard_Local &lt;- localmoran(LondonWards@data$BluePlaqueCount, Lward.lw) I_LWard_Local_Density &lt;- localmoran(LondonWards@data$BlueDensity, Lward.lw) #what does the output (the localMoran object) look like? head(I_LWard_Local_Density) ## Ii E.Ii Var.Ii Z.Ii Pr(z &gt; 0) ## 0 0.08893069 -0.001632161 0.1585720 0.2274243 0.4100469 ## 1 0.13238172 -0.001904187 0.1847261 0.3124398 0.3773532 ## 2 0.10800337 -0.001632161 0.1585720 0.2753202 0.3915351 ## 3 0.11771065 -0.001632161 0.1585720 0.2996974 0.3822040 ## 4 0.11771065 -0.001632161 0.1585720 0.2996974 0.3822040 ## 5 0.11213389 -0.001632161 0.1585720 0.2856929 0.3875567 There are 5 columns of data. We want to copy some of the columns (the I score (column 1) and the z-score standard deviation (column 4)) back into the LondonWards spatialPolygonsDataframe LondonWards@data$BLocI &lt;- I_LWard_Local[,1] LondonWards@data$BLocIz &lt;- I_LWard_Local[,4] LondonWards@data$BLocIR &lt;- I_LWard_Local_Density[,1] LondonWards@data$BLocIRz &lt;- I_LWard_Local_Density[,4] No we can plot a map of the local Moran’s I outputs… We’ll set the breaks manually based on the rule that data points &gt;2.58 or &lt;-2.58 standard deviations away from the mean are significant at the 99% level (&lt;1% chance that autocorrelation not present); &gt;1.96 - &lt;2.58 or &lt;-1.96 to &gt;-2.58 standard deviations are significant at the 95% level (&lt;5% change that autocorrelation not present). &gt;1.65 = 90% etc. #create a new diverging colour brewer palette and reverse the order using rev so higher values correspond to red breaks1&lt;-c(-1000,-2.58,-1.96,-1.65,1.65,1.96,2.58,1000) Now create a new diverging colour brewer palette and reverse the order using rev so higher values correspond to red MoranColours&lt;- rev(brewer.pal(8, &quot;RdGy&quot;)) Plot on an interactive map tm_shape(LondonWards) + tm_polygons(&quot;BLocIRz&quot;, style=&quot;fixed&quot;, breaks=breaks1, palette=MoranColours, midpoint=NA, title=&quot;Local Moran&#39;s I, Blue Plaques in London&quot;) This map shows some areas in the centre of London that have relatively high scores, indicating areas with lots of blue plaques neighbouring other areas with lots of blue plaques. What about the Getis Ord \\(G_{i}^{*}\\) statisic for hot and cold spots? Gi_LWard_Local_Density &lt;- localG(LondonWards@data$BlueDensity, Lward.lw) Check the help file (?localG) to see what a localG object looks like - it is a bit different from a localMoran object as it only contains just a single value - the z-score (standardised value relating to whether high values or low values are clustering together) And map the outputs… head(Gi_LWard_Local_Density) ## [1] -0.8364891 -0.8720954 -0.7679474 -0.8368497 -0.8368497 -0.7972659 LondonWards@data$BLocGiRz &lt;- Gi_LWard_Local_Density And map the outputs… GIColours&lt;- rev(brewer.pal(8, &quot;RdBu&quot;)) #now plot on an interactive map tm_shape(LondonWards) + tm_polygons(&quot;BLocGiRz&quot;, style=&quot;fixed&quot;, breaks=breaks1, palette=GIColours, midpoint=NA, title=&quot;Gi*, Blue Plaques in London&quot;) The local Moran’s I and \\(G_{i}^{*}\\) statistics for wards clearly show that the density of blue plaques in the centre of the city exhibits strong (and postitive) spatial autocorrelation, but neither of these maps are very interesting. The ArcGIS crew will have been calculating Local Moran’s I and \\(G_{i}^{*}\\) statistics for some of the other variables for the wards of London. Why not try some alternative variables and see what patterns emerge… here I’m going to have a look at Average GSCE scores… #use head to see what other variables are in the data file head(LondonWards@data) ## WD11CD WD11CDO WD11NM WD11NMW ## 0 E05000026 00ABFX Abbey &lt;NA&gt; ## 1 E05000027 00ABFY Alibon &lt;NA&gt; ## 2 E05000028 00ABFZ Becontree &lt;NA&gt; ## 3 E05000029 00ABGA Chadwell Heath &lt;NA&gt; ## 4 E05000030 00ABGB Eastbrook &lt;NA&gt; ## 5 E05000031 00ABGC Eastbury &lt;NA&gt; ## WardName OldCode Wardcode Pop2013 Aged0_15 ## 0 Barking and Dagenham - Abbey 00ABFX E05000026 13650 3450 ## 1 Barking and Dagenham - Alibon 00ABFY E05000027 10400 2700 ## 2 Barking and Dagenham - Becontree 00ABFZ E05000028 12050 3000 ## 3 Barking and Dagenham - Chadwell Heath 00ABGA E05000029 10150 2450 ## 4 Barking and Dagenham - Eastbrook 00ABGB E05000030 10600 2150 ## 5 Barking and Dagenham - Eastbury 00ABGC E05000031 11700 3000 ## Aged16_64 Aged65plus PctAged0_1 PctAged16_ PctAged65p MeanAge201 ## 0 9550 700 25.3 70.0 5.1 29.5 ## 1 6600 1100 26.0 63.5 10.6 33.8 ## 2 8000 1100 24.9 66.4 9.1 33.0 ## 3 6150 1550 24.1 60.6 15.3 36.2 ## 4 6900 1550 20.3 65.1 14.6 37.7 ## 5 7550 1150 25.6 64.5 9.8 33.4 ## MedianAge2 AreaSqKM PopDensity PctBame PctNotBorn PctNoEngli GenFertRat ## 0 29 1.3 10500.0 71.9 57.3 25.7 103 ## 1 33 1.4 7428.6 29.9 24.7 7.9 91 ## 2 32 1.3 9269.2 41.2 30.1 10.5 102 ## 3 34 3.4 2985.3 37.9 24.8 6.5 81 ## 4 36 3.5 3028.6 24.8 19.0 4.5 78 ## 5 32 1.4 8357.1 41.7 32.2 11.9 89 ## MaleLE0509 FemaleLE05 PctYr1Obes PctYr6Obes RateAmbula RatesAmbul ## 0 80.0 82.2 15.423728814 21.467391304 164.6886 0.9352518 ## 1 75.8 80.4 12.5 25.853658537 134.5192 0.7837838 ## 2 78.9 78.9 12.857142857 24.874371859 127.8838 0.7010309 ## 3 79.1 81.0 11.751662971 25.816993464 149.5567 0.6000000 ## 4 77.1 80.6 13.942307692 24.324324324 145.0000 0.6666667 ## 5 78.6 84.6 13.621262458 22.608695652 124.2735 0.4666667 ## RoadKilled InEmployme Employment NoJobs2011 EmpWkAgePo RateNINoFo ## 0 3 5489 58.35016 8900 0.9319372 108.69565 ## 1 4 4214 59.26864 900 0.1363636 31.14754 ## 2 1 4674 57.89669 1200 0.1500000 38.55422 ## 3 2 3916 58.67546 1800 0.2926829 26.27119 ## 4 5 4686 62.84871 4000 0.5797101 18.43972 ## 5 2 4620 58.34070 1100 0.1456954 48.92086 ## MeanHouseP NoProperti NoHousehol PctDetache PctSemiDet PctTerrace ## 0 164000 60 4753 3.9 7.2 22.6 ## 1 173500 73 4045 3.8 18.2 63.8 ## 2 178995 147 4378 4.2 24.7 52.0 ## 3 210000 87 4062 3.8 29.6 32.2 ## 4 203500 84 3977 3.2 32.6 45.5 ## 5 187875 75 4321 5.0 21.0 52.5 ## PctFlatMai PctOwned20 PctSocialR PctPrivate PctCTaxBan PctCTaxB_1 ## 0 66.3 32.7 26.7 38.6 45.77158 56.47341 ## 1 14.2 45.1 36.8 15.9 9.29495 90.75384 ## 2 19.1 46.7 29.4 20.1 11.94346 90.76561 ## 3 34.5 54.0 32.0 12.4 33.28380 66.36949 ## 4 18.4 67.6 20.0 11.2 14.81574 84.93526 ## 5 21.5 44.0 37.4 17.3 18.72262 81.41573 ## PctCTaxB_2 Incapacity IncomeSupp EmpSupport JSAClaiman PctDepChil ## 0 0.10897995 1.570681 3.612565 3.403141 8.737771 28.15789 ## 1 0.07318858 3.257576 6.590909 6.060606 9.473789 35.55556 ## 2 0.09422850 2.312500 4.750000 5.500000 10.234388 32.95775 ## 3 0.44576523 2.682927 5.121951 4.634146 8.342021 28.79310 ## 4 0.54780876 1.956522 3.188406 3.623188 8.293168 24.71698 ## 5 0.04611483 2.450331 5.033113 5.099338 9.463746 30.14286 ## PctHHNoAdu PctLonePar IDRankLond IDPctWorst AvgGCSE201 UnauthAbse ## 0 8.748906 55.31062 166 85.71429 330 1.3 ## 1 12.440191 60.99518 124 100.00000 341 1.3 ## 2 10.731821 51.51057 185 100.00000 346 1.4 ## 3 10.147133 55.23979 96 100.00000 327 1.7 ## 4 6.663236 48.69792 288 100.00000 349 1.0 ## 5 11.118914 52.45902 135 100.00000 339 1.4 ## PctWithNoQ PctLev4Qua CrimeRate1 ViolenceRa RobberyRat TheftAndHa ## 0 16.4 34.5 164.4 35.71429 6.541353 71.35338 ## 1 31.2 16.7 83.9 22.88462 3.365385 23.46154 ## 2 28.0 20.6 85.7 17.73109 2.605042 30.25210 ## 3 29.1 19.5 84.5 18.62069 2.758621 28.57143 ## 4 29.9 18.5 64.9 17.74648 2.159624 18.87324 ## 5 28.9 20.0 75.9 17.87234 3.489362 22.29787 ## CriminalDa DrugsRate1 Deliberate PctOpenSpa CarsPerHH2 AvgPubTran ## 0 11.954887 14.060150 0.6 19.60720 0.5476815 5.7 ## 1 10.000000 6.442308 0.3 22.41290 0.8151599 3.2 ## 2 5.882353 6.302521 0.7 3.03888 0.8702361 2.9 ## 3 10.738916 3.349754 1.1 56.40730 0.9180619 2.2 ## 4 5.915493 4.037559 1.0 51.11650 1.0604579 2.4 ## 5 7.744681 4.765957 1.3 18.10540 0.7827715 2.8 ## PctTTWBike TurnoutMay Shape_Leng Shape_Area ID x y ## 0 0.8016032 25.68894 6244.870 1282926 1 544204 184358 ## 1 1.0204082 20.34793 6353.916 1364441 2 549062 185153 ## 2 1.6474112 22.53821 6341.656 1288085 3 547000 186088 ## 3 1.1746680 25.31881 9603.344 3384198 4 548360 189491 ## 4 1.5578318 24.12147 8987.676 3450578 5 550790 186101 ## 5 1.5151515 21.51488 6829.478 1440028 6 546139 183989 ## BluePlaqueCount BlueDensity BLocI BLocIz BLocIR BLocIRz ## 0 1 7.794681e-07 0.05679283 0.1567154 0.08893069 0.2274243 ## 1 0 0.000000e+00 0.08333988 0.2118224 0.13238172 0.3124398 ## 2 0 0.000000e+00 0.06818055 0.1872611 0.10800337 0.2753202 ## 3 0 0.000000e+00 0.07387441 0.2025339 0.11771065 0.2996974 ## 4 0 0.000000e+00 0.07387441 0.2025339 0.11771065 0.2996974 ## 5 0 0.000000e+00 0.06818055 0.1872611 0.11213389 0.2856929 ## BLocGiRz ## 0 -0.8364891 ## 1 -0.8720954 ## 2 -0.7679474 ## 3 -0.8368497 ## 4 -0.8368497 ## 5 -0.7972659 I_LWard_Local_GCSE &lt;- localmoran(LondonWards@data$AvgGCSE201, Lward.lw) LondonWards@data$GCSE_LocIz &lt;- I_LWard_Local_GCSE[,4] tm_shape(LondonWards) + tm_polygons(&quot;GCSE_LocIz&quot;, style=&quot;fixed&quot;, breaks=breaks1, palette=MoranColours, midpoint=NA, title=&quot;Local Moran&#39;s I, GCSE Scores&quot;) Now the Gi* statistic to look at clusters of high and low scores… Gi_LWard_Local_GCSE &lt;- localG(LondonWards@data$AvgGCSE201, Lward.lw) LondonWards@data$GCSE_LocGiz &lt;- Gi_LWard_Local_GCSE tm_shape(LondonWards) + tm_polygons(&quot;GCSE_LocGiz&quot;, style=&quot;fixed&quot;, breaks=breaks1, palette=GIColours, midpoint=NA, title=&quot;Gi*, GCSE Scores&quot;) So this is the end of the practical. Hopefully you have learned a lot about the different methods we can employ to analyse patterns in spatial data. This practical was deliberately designed as a walk through, but this may have given you ideas about where you could perhaps take these techniques in your coursework if this is something you wanted to explore further with different data or in different contexts. Things to perhaps try as an extension… We have used sp objects in this practical (because I wrote it before sf became the defacto spatial data type in R). Can you convert some of this so it works withsf? Could you atomate any of the functions so that you could quickly produce maps of any of the variables in the LondonWards dataset? Could you get these outputs into a faceted ggplot2 map? "]
]
